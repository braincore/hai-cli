// DO NOT EDIT
// This file was @generated by Stone

#![allow(
    dead_code,
    clippy::too_many_arguments,
    clippy::too_many_arguments,
    clippy::large_enum_variant,
    clippy::result_large_err,
    clippy::doc_markdown
)]

#[allow(unused_imports)]
use base64::{engine::general_purpose::STANDARD_NO_PAD as BASE64, Engine as _};

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct ListenAsset {
    /// Cursor from asset/revision/iter with direction set to `newer`.
    pub cursor: String,
}

impl ListenAsset {
    pub fn new(cursor: String) -> Self {
        ListenAsset { cursor }
    }
}

const LISTEN_ASSET_FIELDS: &[&str] = &["cursor"];
impl ListenAsset {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ListenAsset, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ListenAsset>, V::Error> {
        let mut field_cursor = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(::serde::de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ListenAsset {
            cursor: field_cursor.ok_or_else(|| ::serde::de::Error::missing_field("cursor"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("cursor", &self.cursor)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListenAsset {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListenAsset;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ListenAsset struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListenAsset::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListenAsset", LISTEN_ASSET_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListenAsset {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListenAsset", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct ListenAssetPool {
    /// Cursor from asset/entry/iter.
    pub cursor: String,
}

impl ListenAssetPool {
    pub fn new(cursor: String) -> Self {
        ListenAssetPool { cursor }
    }
}

const LISTEN_ASSET_POOL_FIELDS: &[&str] = &["cursor"];
impl ListenAssetPool {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<ListenAssetPool, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<ListenAssetPool>, V::Error> {
        let mut field_cursor = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(::serde::de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = ListenAssetPool {
            cursor: field_cursor.ok_or_else(|| ::serde::de::Error::missing_field("cursor"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("cursor", &self.cursor)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ListenAssetPool {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ListenAssetPool;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ListenAssetPool struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ListenAssetPool::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("ListenAssetPool", LISTEN_ASSET_POOL_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for ListenAssetPool {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("ListenAssetPool", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum NotifyListenArg {
    AssetPool(ListenAssetPool),
    Asset(ListenAsset),
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for NotifyListenArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = NotifyListenArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a NotifyListenArg structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "asset_pool" => {
                        NotifyListenArg::AssetPool(ListenAssetPool::internal_deserialize(&mut map)?)
                    }
                    "asset" => NotifyListenArg::Asset(ListenAsset::internal_deserialize(&mut map)?),
                    _ => NotifyListenArg::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["asset_pool", "asset", "other"];
        deserializer.deserialize_struct("NotifyListenArg", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for NotifyListenArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            NotifyListenArg::AssetPool(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("NotifyListenArg", 2)?;
                s.serialize_field(".tag", "asset_pool")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            NotifyListenArg::Asset(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("NotifyListenArg", 2)?;
                s.serialize_field(".tag", "asset")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            NotifyListenArg::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}
