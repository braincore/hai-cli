// DO NOT EDIT
// This file was @generated by Stone

#![allow(
    dead_code,
    clippy::too_many_arguments,
    clippy::too_many_arguments,
    clippy::large_enum_variant,
    clippy::result_large_err,
    clippy::doc_markdown
)]

#[allow(unused_imports)]
use base64::{Engine as _, engine::general_purpose::STANDARD_NO_PAD as BASE64};

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum BadConfigError {
    ConfigTooLarge,
    BadToml,
    MissingName,
    MissingDescription,
    MissingVersion,
    MissingSteps,
    TooManySteps,
    BadName,
    BadDescription,
    BadDependency,
    InvalidVersion,
    VersionAlreadyExists,
    VersionNonmonotonic,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for BadConfigError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = BadConfigError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a BadConfigError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "config_too_large" => BadConfigError::ConfigTooLarge,
                    "bad_toml" => BadConfigError::BadToml,
                    "missing_name" => BadConfigError::MissingName,
                    "missing_description" => BadConfigError::MissingDescription,
                    "missing_version" => BadConfigError::MissingVersion,
                    "missing_steps" => BadConfigError::MissingSteps,
                    "too_many_steps" => BadConfigError::TooManySteps,
                    "bad_name" => BadConfigError::BadName,
                    "bad_description" => BadConfigError::BadDescription,
                    "bad_dependency" => BadConfigError::BadDependency,
                    "invalid_version" => BadConfigError::InvalidVersion,
                    "version_already_exists" => BadConfigError::VersionAlreadyExists,
                    "version_nonmonotonic" => BadConfigError::VersionNonmonotonic,
                    _ => BadConfigError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &[
            "config_too_large",
            "bad_toml",
            "missing_name",
            "missing_description",
            "missing_version",
            "missing_steps",
            "too_many_steps",
            "bad_name",
            "bad_description",
            "bad_dependency",
            "invalid_version",
            "version_already_exists",
            "version_nonmonotonic",
            "other",
        ];
        deserializer.deserialize_struct("BadConfigError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for BadConfigError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            BadConfigError::ConfigTooLarge => {
                // unit
                let mut s = serializer.serialize_struct("BadConfigError", 1)?;
                s.serialize_field(".tag", "config_too_large")?;
                s.end()
            }
            BadConfigError::BadToml => {
                // unit
                let mut s = serializer.serialize_struct("BadConfigError", 1)?;
                s.serialize_field(".tag", "bad_toml")?;
                s.end()
            }
            BadConfigError::MissingName => {
                // unit
                let mut s = serializer.serialize_struct("BadConfigError", 1)?;
                s.serialize_field(".tag", "missing_name")?;
                s.end()
            }
            BadConfigError::MissingDescription => {
                // unit
                let mut s = serializer.serialize_struct("BadConfigError", 1)?;
                s.serialize_field(".tag", "missing_description")?;
                s.end()
            }
            BadConfigError::MissingVersion => {
                // unit
                let mut s = serializer.serialize_struct("BadConfigError", 1)?;
                s.serialize_field(".tag", "missing_version")?;
                s.end()
            }
            BadConfigError::MissingSteps => {
                // unit
                let mut s = serializer.serialize_struct("BadConfigError", 1)?;
                s.serialize_field(".tag", "missing_steps")?;
                s.end()
            }
            BadConfigError::TooManySteps => {
                // unit
                let mut s = serializer.serialize_struct("BadConfigError", 1)?;
                s.serialize_field(".tag", "too_many_steps")?;
                s.end()
            }
            BadConfigError::BadName => {
                // unit
                let mut s = serializer.serialize_struct("BadConfigError", 1)?;
                s.serialize_field(".tag", "bad_name")?;
                s.end()
            }
            BadConfigError::BadDescription => {
                // unit
                let mut s = serializer.serialize_struct("BadConfigError", 1)?;
                s.serialize_field(".tag", "bad_description")?;
                s.end()
            }
            BadConfigError::BadDependency => {
                // unit
                let mut s = serializer.serialize_struct("BadConfigError", 1)?;
                s.serialize_field(".tag", "bad_dependency")?;
                s.end()
            }
            BadConfigError::InvalidVersion => {
                // unit
                let mut s = serializer.serialize_struct("BadConfigError", 1)?;
                s.serialize_field(".tag", "invalid_version")?;
                s.end()
            }
            BadConfigError::VersionAlreadyExists => {
                // unit
                let mut s = serializer.serialize_struct("BadConfigError", 1)?;
                s.serialize_field(".tag", "version_already_exists")?;
                s.end()
            }
            BadConfigError::VersionNonmonotonic => {
                // unit
                let mut s = serializer.serialize_struct("BadConfigError", 1)?;
                s.serialize_field(".tag", "version_nonmonotonic")?;
                s.end()
            }
            BadConfigError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for BadConfigError {}

impl ::std::fmt::Display for BadConfigError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct TaskGetArg {
    /// Task's fully-qualified name
    pub task_fqn: String,
}

impl TaskGetArg {
    pub fn new(task_fqn: String) -> Self {
        TaskGetArg { task_fqn }
    }
}

const TASK_GET_ARG_FIELDS: &[&str] = &["task_fqn"];
impl TaskGetArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TaskGetArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TaskGetArg>, V::Error> {
        let mut field_task_fqn = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "task_fqn" => {
                    if field_task_fqn.is_some() {
                        return Err(::serde::de::Error::duplicate_field("task_fqn"));
                    }
                    field_task_fqn = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TaskGetArg {
            task_fqn: field_task_fqn
                .ok_or_else(|| ::serde::de::Error::missing_field("task_fqn"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("task_fqn", &self.task_fqn)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TaskGetArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TaskGetArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TaskGetArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TaskGetArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TaskGetArg", TASK_GET_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TaskGetArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TaskGetArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum TaskGetError {
    TaskNotFound,
    VersionNotFound,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TaskGetError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TaskGetError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TaskGetError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "task_not_found" => TaskGetError::TaskNotFound,
                    "version_not_found" => TaskGetError::VersionNotFound,
                    _ => TaskGetError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["task_not_found", "version_not_found", "other"];
        deserializer.deserialize_struct("TaskGetError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TaskGetError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TaskGetError::TaskNotFound => {
                // unit
                let mut s = serializer.serialize_struct("TaskGetError", 1)?;
                s.serialize_field(".tag", "task_not_found")?;
                s.end()
            }
            TaskGetError::VersionNotFound => {
                // unit
                let mut s = serializer.serialize_struct("TaskGetError", 1)?;
                s.serialize_field(".tag", "version_not_found")?;
                s.end()
            }
            TaskGetError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for TaskGetError {}

impl ::std::fmt::Display for TaskGetError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct TaskGetResult {
    pub task_id: String,
    pub task_fqn: String,
    pub task_version: String,
    pub config: String,
}

impl TaskGetResult {
    pub fn new(task_id: String, task_fqn: String, task_version: String, config: String) -> Self {
        TaskGetResult {
            task_id,
            task_fqn,
            task_version,
            config,
        }
    }
}

const TASK_GET_RESULT_FIELDS: &[&str] = &["task_id", "task_fqn", "task_version", "config"];
impl TaskGetResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TaskGetResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TaskGetResult>, V::Error> {
        let mut field_task_id = None;
        let mut field_task_fqn = None;
        let mut field_task_version = None;
        let mut field_config = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "task_id" => {
                    if field_task_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("task_id"));
                    }
                    field_task_id = Some(map.next_value()?);
                }
                "task_fqn" => {
                    if field_task_fqn.is_some() {
                        return Err(::serde::de::Error::duplicate_field("task_fqn"));
                    }
                    field_task_fqn = Some(map.next_value()?);
                }
                "task_version" => {
                    if field_task_version.is_some() {
                        return Err(::serde::de::Error::duplicate_field("task_version"));
                    }
                    field_task_version = Some(map.next_value()?);
                }
                "config" => {
                    if field_config.is_some() {
                        return Err(::serde::de::Error::duplicate_field("config"));
                    }
                    field_config = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TaskGetResult {
            task_id: field_task_id.ok_or_else(|| ::serde::de::Error::missing_field("task_id"))?,
            task_fqn: field_task_fqn
                .ok_or_else(|| ::serde::de::Error::missing_field("task_fqn"))?,
            task_version: field_task_version
                .ok_or_else(|| ::serde::de::Error::missing_field("task_version"))?,
            config: field_config.ok_or_else(|| ::serde::de::Error::missing_field("config"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("task_id", &self.task_id)?;
        s.serialize_field("task_fqn", &self.task_fqn)?;
        s.serialize_field("task_version", &self.task_version)?;
        s.serialize_field("config", &self.config)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TaskGetResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TaskGetResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TaskGetResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TaskGetResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TaskGetResult", TASK_GET_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TaskGetResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TaskGetResult", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct TaskListVersionsArg {
    /// Task's fully-qualified name
    pub task_fqn: String,
}

impl TaskListVersionsArg {
    pub fn new(task_fqn: String) -> Self {
        TaskListVersionsArg { task_fqn }
    }
}

const TASK_LIST_VERSIONS_ARG_FIELDS: &[&str] = &["task_fqn"];
impl TaskListVersionsArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TaskListVersionsArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TaskListVersionsArg>, V::Error> {
        let mut field_task_fqn = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "task_fqn" => {
                    if field_task_fqn.is_some() {
                        return Err(::serde::de::Error::duplicate_field("task_fqn"));
                    }
                    field_task_fqn = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TaskListVersionsArg {
            task_fqn: field_task_fqn
                .ok_or_else(|| ::serde::de::Error::missing_field("task_fqn"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("task_fqn", &self.task_fqn)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TaskListVersionsArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TaskListVersionsArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TaskListVersionsArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TaskListVersionsArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "TaskListVersionsArg",
            TASK_LIST_VERSIONS_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for TaskListVersionsArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TaskListVersionsArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum TaskListVersionsError {
    TaskNotFound,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TaskListVersionsError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TaskListVersionsError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TaskListVersionsError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "task_not_found" => TaskListVersionsError::TaskNotFound,
                    _ => TaskListVersionsError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["task_not_found", "other"];
        deserializer.deserialize_struct("TaskListVersionsError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TaskListVersionsError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TaskListVersionsError::TaskNotFound => {
                // unit
                let mut s = serializer.serialize_struct("TaskListVersionsError", 1)?;
                s.serialize_field(".tag", "task_not_found")?;
                s.end()
            }
            TaskListVersionsError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for TaskListVersionsError {}

impl ::std::fmt::Display for TaskListVersionsError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct TaskListVersionsResult {
    pub versions: Vec<String>,
}

impl TaskListVersionsResult {
    pub fn new(versions: Vec<String>) -> Self {
        TaskListVersionsResult { versions }
    }
}

const TASK_LIST_VERSIONS_RESULT_FIELDS: &[&str] = &["versions"];
impl TaskListVersionsResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TaskListVersionsResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TaskListVersionsResult>, V::Error> {
        let mut field_versions = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "versions" => {
                    if field_versions.is_some() {
                        return Err(::serde::de::Error::duplicate_field("versions"));
                    }
                    field_versions = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TaskListVersionsResult {
            versions: field_versions
                .ok_or_else(|| ::serde::de::Error::missing_field("versions"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("versions", &self.versions)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TaskListVersionsResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TaskListVersionsResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TaskListVersionsResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TaskListVersionsResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "TaskListVersionsResult",
            TASK_LIST_VERSIONS_RESULT_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for TaskListVersionsResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TaskListVersionsResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct TaskPutArg {
    /// Task's fully-qualified name
    pub task_fqn: String,
    /// TOML file describing task
    pub config: String,
}

impl TaskPutArg {
    pub fn new(task_fqn: String, config: String) -> Self {
        TaskPutArg { task_fqn, config }
    }
}

const TASK_PUT_ARG_FIELDS: &[&str] = &["task_fqn", "config"];
impl TaskPutArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TaskPutArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TaskPutArg>, V::Error> {
        let mut field_task_fqn = None;
        let mut field_config = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "task_fqn" => {
                    if field_task_fqn.is_some() {
                        return Err(::serde::de::Error::duplicate_field("task_fqn"));
                    }
                    field_task_fqn = Some(map.next_value()?);
                }
                "config" => {
                    if field_config.is_some() {
                        return Err(::serde::de::Error::duplicate_field("config"));
                    }
                    field_config = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TaskPutArg {
            task_fqn: field_task_fqn
                .ok_or_else(|| ::serde::de::Error::missing_field("task_fqn"))?,
            config: field_config.ok_or_else(|| ::serde::de::Error::missing_field("config"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("task_fqn", &self.task_fqn)?;
        s.serialize_field("config", &self.config)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TaskPutArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TaskPutArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TaskPutArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TaskPutArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TaskPutArg", TASK_PUT_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TaskPutArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TaskPutArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum TaskPutError {
    NoPermission,
    BadFqn,
    BadConfig(BadConfigError),
    TooManyTasks,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TaskPutError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TaskPutError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TaskPutError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "no_permission" => TaskPutError::NoPermission,
                    "bad_fqn" => TaskPutError::BadFqn,
                    "bad_config" => match map.next_key()? {
                        Some("bad_config") => TaskPutError::BadConfig(map.next_value()?),
                        None => return Err(de::Error::missing_field("bad_config")),
                        _ => return Err(de::Error::unknown_field(tag, VARIANTS)),
                    },
                    "too_many_tasks" => TaskPutError::TooManyTasks,
                    _ => TaskPutError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &[
            "no_permission",
            "bad_fqn",
            "bad_config",
            "too_many_tasks",
            "other",
        ];
        deserializer.deserialize_struct("TaskPutError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TaskPutError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TaskPutError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("TaskPutError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            TaskPutError::BadFqn => {
                // unit
                let mut s = serializer.serialize_struct("TaskPutError", 1)?;
                s.serialize_field(".tag", "bad_fqn")?;
                s.end()
            }
            TaskPutError::BadConfig(ref x) => {
                // union or polymporphic struct
                let mut s = serializer.serialize_struct("TaskPutError", 2)?;
                s.serialize_field(".tag", "bad_config")?;
                s.serialize_field("bad_config", x)?;
                s.end()
            }
            TaskPutError::TooManyTasks => {
                // unit
                let mut s = serializer.serialize_struct("TaskPutError", 1)?;
                s.serialize_field(".tag", "too_many_tasks")?;
                s.end()
            }
            TaskPutError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for TaskPutError {
    fn source(&self) -> Option<&(dyn ::std::error::Error + 'static)> {
        match self {
            TaskPutError::BadConfig(inner) => Some(inner),
            _ => None,
        }
    }
}

impl ::std::fmt::Display for TaskPutError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            TaskPutError::BadConfig(inner) => write!(f, "{}", inner),
            _ => write!(f, "{:?}", *self),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct TaskSearchArg {
    /// The search query.
    pub q: String,
}

impl TaskSearchArg {
    pub fn new(q: String) -> Self {
        TaskSearchArg { q }
    }
}

const TASK_SEARCH_ARG_FIELDS: &[&str] = &["q"];
impl TaskSearchArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TaskSearchArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TaskSearchArg>, V::Error> {
        let mut field_q = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "q" => {
                    if field_q.is_some() {
                        return Err(::serde::de::Error::duplicate_field("q"));
                    }
                    field_q = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TaskSearchArg {
            q: field_q.ok_or_else(|| ::serde::de::Error::missing_field("q"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("q", &self.q)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TaskSearchArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TaskSearchArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TaskSearchArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TaskSearchArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TaskSearchArg", TASK_SEARCH_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TaskSearchArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TaskSearchArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum TaskSearchError {
    BadQ,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for TaskSearchError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = TaskSearchError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TaskSearchError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_q" => TaskSearchError::BadQ,
                    _ => TaskSearchError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["bad_q", "other"];
        deserializer.deserialize_struct("TaskSearchError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for TaskSearchError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            TaskSearchError::BadQ => {
                // unit
                let mut s = serializer.serialize_struct("TaskSearchError", 1)?;
                s.serialize_field(".tag", "bad_q")?;
                s.end()
            }
            TaskSearchError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for TaskSearchError {}

impl ::std::fmt::Display for TaskSearchError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct TaskSearchMatch {
    pub task_id: String,
    pub task_fqn: String,
    pub task_version: String,
    /// Number of times a task has been downloaded. This is an aggregate across all versions.
    pub downloads: u64,
    pub description: Option<String>,
}

impl TaskSearchMatch {
    pub fn new(task_id: String, task_fqn: String, task_version: String, downloads: u64) -> Self {
        TaskSearchMatch {
            task_id,
            task_fqn,
            task_version,
            downloads,
            description: None,
        }
    }

    pub fn with_description(mut self, value: String) -> Self {
        self.description = Some(value);
        self
    }
}

const TASK_SEARCH_MATCH_FIELDS: &[&str] = &[
    "task_id",
    "task_fqn",
    "task_version",
    "downloads",
    "description",
];
impl TaskSearchMatch {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TaskSearchMatch, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TaskSearchMatch>, V::Error> {
        let mut field_task_id = None;
        let mut field_task_fqn = None;
        let mut field_task_version = None;
        let mut field_downloads = None;
        let mut field_description = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "task_id" => {
                    if field_task_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("task_id"));
                    }
                    field_task_id = Some(map.next_value()?);
                }
                "task_fqn" => {
                    if field_task_fqn.is_some() {
                        return Err(::serde::de::Error::duplicate_field("task_fqn"));
                    }
                    field_task_fqn = Some(map.next_value()?);
                }
                "task_version" => {
                    if field_task_version.is_some() {
                        return Err(::serde::de::Error::duplicate_field("task_version"));
                    }
                    field_task_version = Some(map.next_value()?);
                }
                "downloads" => {
                    if field_downloads.is_some() {
                        return Err(::serde::de::Error::duplicate_field("downloads"));
                    }
                    field_downloads = Some(map.next_value()?);
                }
                "description" => {
                    if field_description.is_some() {
                        return Err(::serde::de::Error::duplicate_field("description"));
                    }
                    field_description = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TaskSearchMatch {
            task_id: field_task_id.ok_or_else(|| ::serde::de::Error::missing_field("task_id"))?,
            task_fqn: field_task_fqn
                .ok_or_else(|| ::serde::de::Error::missing_field("task_fqn"))?,
            task_version: field_task_version
                .ok_or_else(|| ::serde::de::Error::missing_field("task_version"))?,
            downloads: field_downloads
                .ok_or_else(|| ::serde::de::Error::missing_field("downloads"))?,
            description: field_description.and_then(Option::flatten),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("task_id", &self.task_id)?;
        s.serialize_field("task_fqn", &self.task_fqn)?;
        s.serialize_field("task_version", &self.task_version)?;
        s.serialize_field("downloads", &self.downloads)?;
        if let Some(val) = &self.description {
            s.serialize_field("description", val)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TaskSearchMatch {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TaskSearchMatch;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TaskSearchMatch struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TaskSearchMatch::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TaskSearchMatch", TASK_SEARCH_MATCH_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TaskSearchMatch {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TaskSearchMatch", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct TaskSearchResult {
    pub semantic_matches: Vec<TaskSearchMatch>,
    pub syntactic_matches: Vec<TaskSearchMatch>,
}

impl TaskSearchResult {
    pub fn new(
        semantic_matches: Vec<TaskSearchMatch>,
        syntactic_matches: Vec<TaskSearchMatch>,
    ) -> Self {
        TaskSearchResult {
            semantic_matches,
            syntactic_matches,
        }
    }
}

const TASK_SEARCH_RESULT_FIELDS: &[&str] = &["semantic_matches", "syntactic_matches"];
impl TaskSearchResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TaskSearchResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TaskSearchResult>, V::Error> {
        let mut field_semantic_matches = None;
        let mut field_syntactic_matches = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "semantic_matches" => {
                    if field_semantic_matches.is_some() {
                        return Err(::serde::de::Error::duplicate_field("semantic_matches"));
                    }
                    field_semantic_matches = Some(map.next_value()?);
                }
                "syntactic_matches" => {
                    if field_syntactic_matches.is_some() {
                        return Err(::serde::de::Error::duplicate_field("syntactic_matches"));
                    }
                    field_syntactic_matches = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TaskSearchResult {
            semantic_matches: field_semantic_matches
                .ok_or_else(|| ::serde::de::Error::missing_field("semantic_matches"))?,
            syntactic_matches: field_syntactic_matches
                .ok_or_else(|| ::serde::de::Error::missing_field("syntactic_matches"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("semantic_matches", &self.semantic_matches)?;
        s.serialize_field("syntactic_matches", &self.syntactic_matches)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TaskSearchResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TaskSearchResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TaskSearchResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TaskSearchResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "TaskSearchResult",
            TASK_SEARCH_RESULT_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for TaskSearchResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TaskSearchResult", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}
