// DO NOT EDIT
// This file was @generated by Stone

#![allow(
    dead_code,
    clippy::too_many_arguments,
    clippy::too_many_arguments,
    clippy::large_enum_variant,
    clippy::result_large_err,
    clippy::doc_markdown
)]

#[allow(unused_imports)]
use base64::{engine::general_purpose::STANDARD_NO_PAD as BASE64, Engine as _};

/// Access Control Entry (ACE)
#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AceType {
    Allow,
    Deny,
    Default,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AceType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AceType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AceType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "allow" => AceType::Allow,
                    "deny" => AceType::Deny,
                    "default" => AceType::Default,
                    _ => AceType::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["allow", "deny", "default", "other"];
        deserializer.deserialize_struct("AceType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AceType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AceType::Allow => {
                // unit
                let mut s = serializer.serialize_struct("AceType", 1)?;
                s.serialize_field(".tag", "allow")?;
                s.end()
            }
            AceType::Deny => {
                // unit
                let mut s = serializer.serialize_struct("AceType", 1)?;
                s.serialize_field(".tag", "deny")?;
                s.end()
            }
            AceType::Default => {
                // unit
                let mut s = serializer.serialize_struct("AceType", 1)?;
                s.serialize_field(".tag", "default")?;
                s.end()
            }
            AceType::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetCreatedBy {
    User(AssetCreatedByUser),
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetCreatedBy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetCreatedBy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetCreatedBy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "user" => {
                        AssetCreatedBy::User(AssetCreatedByUser::internal_deserialize(&mut map)?)
                    }
                    _ => AssetCreatedBy::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["user", "other"];
        deserializer.deserialize_struct("AssetCreatedBy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetCreatedBy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetCreatedBy::User(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("AssetCreatedBy", 2)?;
                s.serialize_field(".tag", "user")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            AssetCreatedBy::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetCreatedByUser {
    pub username: String,
}

impl AssetCreatedByUser {
    pub fn new(username: String) -> Self {
        AssetCreatedByUser { username }
    }
}

const ASSET_CREATED_BY_USER_FIELDS: &[&str] = &["username"];
impl AssetCreatedByUser {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetCreatedByUser, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetCreatedByUser>, V::Error> {
        let mut field_username = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "username" => {
                    if field_username.is_some() {
                        return Err(::serde::de::Error::duplicate_field("username"));
                    }
                    field_username = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetCreatedByUser {
            username: field_username
                .ok_or_else(|| ::serde::de::Error::missing_field("username"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("username", &self.username)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetCreatedByUser {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetCreatedByUser;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetCreatedByUser struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetCreatedByUser::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetCreatedByUser",
            ASSET_CREATED_BY_USER_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetCreatedByUser {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetCreatedByUser", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetEntry {
    pub entry_id: String,
    pub name: String,
    pub op: AssetEntryOp,
    pub asset: AssetInfo,
    /// The total size of all revisions of a given asset and metadata. This is important because a
    /// user's quota is based on the sum of all revisions.
    pub total_size: u64,
    pub metadata: Option<AssetMetadataInfo>,
}

impl AssetEntry {
    pub fn new(
        entry_id: String,
        name: String,
        op: AssetEntryOp,
        asset: AssetInfo,
        total_size: u64,
    ) -> Self {
        AssetEntry {
            entry_id,
            name,
            op,
            asset,
            total_size,
            metadata: None,
        }
    }

    pub fn with_metadata(mut self, value: AssetMetadataInfo) -> Self {
        self.metadata = Some(value);
        self
    }
}

const ASSET_ENTRY_FIELDS: &[&str] = &["entry_id", "name", "op", "asset", "total_size", "metadata"];
impl AssetEntry {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetEntry, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetEntry>, V::Error> {
        let mut field_entry_id = None;
        let mut field_name = None;
        let mut field_op = None;
        let mut field_asset = None;
        let mut field_total_size = None;
        let mut field_metadata = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "entry_id" => {
                    if field_entry_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("entry_id"));
                    }
                    field_entry_id = Some(map.next_value()?);
                }
                "name" => {
                    if field_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "op" => {
                    if field_op.is_some() {
                        return Err(::serde::de::Error::duplicate_field("op"));
                    }
                    field_op = Some(map.next_value()?);
                }
                "asset" => {
                    if field_asset.is_some() {
                        return Err(::serde::de::Error::duplicate_field("asset"));
                    }
                    field_asset = Some(map.next_value()?);
                }
                "total_size" => {
                    if field_total_size.is_some() {
                        return Err(::serde::de::Error::duplicate_field("total_size"));
                    }
                    field_total_size = Some(map.next_value()?);
                }
                "metadata" => {
                    if field_metadata.is_some() {
                        return Err(::serde::de::Error::duplicate_field("metadata"));
                    }
                    field_metadata = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetEntry {
            entry_id: field_entry_id
                .ok_or_else(|| ::serde::de::Error::missing_field("entry_id"))?,
            name: field_name.ok_or_else(|| ::serde::de::Error::missing_field("name"))?,
            op: field_op.ok_or_else(|| ::serde::de::Error::missing_field("op"))?,
            asset: field_asset.ok_or_else(|| ::serde::de::Error::missing_field("asset"))?,
            total_size: field_total_size
                .ok_or_else(|| ::serde::de::Error::missing_field("total_size"))?,
            metadata: field_metadata.and_then(Option::flatten),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("entry_id", &self.entry_id)?;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("op", &self.op)?;
        s.serialize_field("asset", &self.asset)?;
        s.serialize_field("total_size", &self.total_size)?;
        if let Some(val) = &self.metadata {
            s.serialize_field("metadata", val)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntry {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetEntry;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntry struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetEntry::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AssetEntry", ASSET_ENTRY_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AssetEntry {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetEntry", 6)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetEntryAcl {
    pub read_data: AceType,
    pub push_data: AceType,
    pub read_revisions: AceType,
}

impl AssetEntryAcl {
    pub fn new(read_data: AceType, push_data: AceType, read_revisions: AceType) -> Self {
        AssetEntryAcl {
            read_data,
            push_data,
            read_revisions,
        }
    }
}

const ASSET_ENTRY_ACL_FIELDS: &[&str] = &["read_data", "push_data", "read_revisions"];
impl AssetEntryAcl {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetEntryAcl, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetEntryAcl>, V::Error> {
        let mut field_read_data = None;
        let mut field_push_data = None;
        let mut field_read_revisions = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "read_data" => {
                    if field_read_data.is_some() {
                        return Err(::serde::de::Error::duplicate_field("read_data"));
                    }
                    field_read_data = Some(map.next_value()?);
                }
                "push_data" => {
                    if field_push_data.is_some() {
                        return Err(::serde::de::Error::duplicate_field("push_data"));
                    }
                    field_push_data = Some(map.next_value()?);
                }
                "read_revisions" => {
                    if field_read_revisions.is_some() {
                        return Err(::serde::de::Error::duplicate_field("read_revisions"));
                    }
                    field_read_revisions = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetEntryAcl {
            read_data: field_read_data
                .ok_or_else(|| ::serde::de::Error::missing_field("read_data"))?,
            push_data: field_push_data
                .ok_or_else(|| ::serde::de::Error::missing_field("push_data"))?,
            read_revisions: field_read_revisions
                .ok_or_else(|| ::serde::de::Error::missing_field("read_revisions"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("read_data", &self.read_data)?;
        s.serialize_field("push_data", &self.push_data)?;
        s.serialize_field("read_revisions", &self.read_revisions)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntryAcl {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetEntryAcl;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntryAcl struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetEntryAcl::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AssetEntryAcl", ASSET_ENTRY_ACL_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AssetEntryAcl {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetEntryAcl", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetEntryAclGetArg {
    pub entry_ref: EntryRef,
}

impl AssetEntryAclGetArg {
    pub fn new(entry_ref: EntryRef) -> Self {
        AssetEntryAclGetArg { entry_ref }
    }
}

const ASSET_ENTRY_ACL_GET_ARG_FIELDS: &[&str] = &["entry_ref"];
impl AssetEntryAclGetArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetEntryAclGetArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetEntryAclGetArg>, V::Error> {
        let mut field_entry_ref = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "entry_ref" => {
                    if field_entry_ref.is_some() {
                        return Err(::serde::de::Error::duplicate_field("entry_ref"));
                    }
                    field_entry_ref = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetEntryAclGetArg {
            entry_ref: field_entry_ref
                .ok_or_else(|| ::serde::de::Error::missing_field("entry_ref"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("entry_ref", &self.entry_ref)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntryAclGetArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetEntryAclGetArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntryAclGetArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetEntryAclGetArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetEntryAclGetArg",
            ASSET_ENTRY_ACL_GET_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetEntryAclGetArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetEntryAclGetArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetEntryAclGetError {
    BadEntryRef,
    NoPermission,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntryAclGetError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetEntryAclGetError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntryAclGetError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_entry_ref" => AssetEntryAclGetError::BadEntryRef,
                    "no_permission" => AssetEntryAclGetError::NoPermission,
                    _ => AssetEntryAclGetError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["bad_entry_ref", "no_permission", "other"];
        deserializer.deserialize_struct("AssetEntryAclGetError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetEntryAclGetError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetEntryAclGetError::BadEntryRef => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryAclGetError", 1)?;
                s.serialize_field(".tag", "bad_entry_ref")?;
                s.end()
            }
            AssetEntryAclGetError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryAclGetError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetEntryAclGetError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetEntryAclGetError {}

impl ::std::fmt::Display for AssetEntryAclGetError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetEntryAclSetArg {
    pub entry_ref: EntryRef,
    pub read_data: Option<AceType>,
    pub push_data: Option<AceType>,
    pub read_revisions: Option<AceType>,
}

impl AssetEntryAclSetArg {
    pub fn new(entry_ref: EntryRef) -> Self {
        AssetEntryAclSetArg {
            entry_ref,
            read_data: None,
            push_data: None,
            read_revisions: None,
        }
    }

    pub fn with_read_data(mut self, value: AceType) -> Self {
        self.read_data = Some(value);
        self
    }

    pub fn with_push_data(mut self, value: AceType) -> Self {
        self.push_data = Some(value);
        self
    }

    pub fn with_read_revisions(mut self, value: AceType) -> Self {
        self.read_revisions = Some(value);
        self
    }
}

const ASSET_ENTRY_ACL_SET_ARG_FIELDS: &[&str] =
    &["entry_ref", "read_data", "push_data", "read_revisions"];
impl AssetEntryAclSetArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetEntryAclSetArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetEntryAclSetArg>, V::Error> {
        let mut field_entry_ref = None;
        let mut field_read_data = None;
        let mut field_push_data = None;
        let mut field_read_revisions = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "entry_ref" => {
                    if field_entry_ref.is_some() {
                        return Err(::serde::de::Error::duplicate_field("entry_ref"));
                    }
                    field_entry_ref = Some(map.next_value()?);
                }
                "read_data" => {
                    if field_read_data.is_some() {
                        return Err(::serde::de::Error::duplicate_field("read_data"));
                    }
                    field_read_data = Some(map.next_value()?);
                }
                "push_data" => {
                    if field_push_data.is_some() {
                        return Err(::serde::de::Error::duplicate_field("push_data"));
                    }
                    field_push_data = Some(map.next_value()?);
                }
                "read_revisions" => {
                    if field_read_revisions.is_some() {
                        return Err(::serde::de::Error::duplicate_field("read_revisions"));
                    }
                    field_read_revisions = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetEntryAclSetArg {
            entry_ref: field_entry_ref
                .ok_or_else(|| ::serde::de::Error::missing_field("entry_ref"))?,
            read_data: field_read_data.and_then(Option::flatten),
            push_data: field_push_data.and_then(Option::flatten),
            read_revisions: field_read_revisions.and_then(Option::flatten),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("entry_ref", &self.entry_ref)?;
        if let Some(val) = &self.read_data {
            s.serialize_field("read_data", val)?;
        }
        if let Some(val) = &self.push_data {
            s.serialize_field("push_data", val)?;
        }
        if let Some(val) = &self.read_revisions {
            s.serialize_field("read_revisions", val)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntryAclSetArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetEntryAclSetArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntryAclSetArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetEntryAclSetArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetEntryAclSetArg",
            ASSET_ENTRY_ACL_SET_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetEntryAclSetArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetEntryAclSetArg", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetEntryAclSetError {
    BadEntryRef,
    NoPermission,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntryAclSetError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetEntryAclSetError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntryAclSetError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_entry_ref" => AssetEntryAclSetError::BadEntryRef,
                    "no_permission" => AssetEntryAclSetError::NoPermission,
                    _ => AssetEntryAclSetError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["bad_entry_ref", "no_permission", "other"];
        deserializer.deserialize_struct("AssetEntryAclSetError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetEntryAclSetError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetEntryAclSetError::BadEntryRef => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryAclSetError", 1)?;
                s.serialize_field(".tag", "bad_entry_ref")?;
                s.end()
            }
            AssetEntryAclSetError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryAclSetError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetEntryAclSetError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetEntryAclSetError {}

impl ::std::fmt::Display for AssetEntryAclSetError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Default)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetEntryListArg {
    pub prefix: Option<String>,
}

impl AssetEntryListArg {
    pub fn with_prefix(mut self, value: String) -> Self {
        self.prefix = Some(value);
        self
    }
}

const ASSET_ENTRY_LIST_ARG_FIELDS: &[&str] = &["prefix"];
impl AssetEntryListArg {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AssetEntryListArg, V::Error> {
        let mut field_prefix = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "prefix" => {
                    if field_prefix.is_some() {
                        return Err(::serde::de::Error::duplicate_field("prefix"));
                    }
                    field_prefix = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = AssetEntryListArg {
            prefix: field_prefix.and_then(Option::flatten),
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        if let Some(val) = &self.prefix {
            s.serialize_field("prefix", val)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntryListArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetEntryListArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntryListArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetEntryListArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetEntryListArg",
            ASSET_ENTRY_LIST_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetEntryListArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetEntryListArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetEntryListError {
    NoPermission,
    /// This beta endpoint isn't intended to be used for users with large numbers of assets.
    TooManyAssets,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntryListError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetEntryListError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntryListError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "no_permission" => AssetEntryListError::NoPermission,
                    "too_many_assets" => AssetEntryListError::TooManyAssets,
                    _ => AssetEntryListError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["no_permission", "too_many_assets", "other"];
        deserializer.deserialize_struct("AssetEntryListError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetEntryListError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetEntryListError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryListError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetEntryListError::TooManyAssets => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryListError", 1)?;
                s.serialize_field(".tag", "too_many_assets")?;
                s.end()
            }
            AssetEntryListError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetEntryListError {}

impl ::std::fmt::Display for AssetEntryListError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            AssetEntryListError::TooManyAssets => f.write_str("This beta endpoint isn't intended to be used for users with large numbers of assets."),
            _ => write!(f, "{:?}", *self),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetEntryListResult {
    pub entries: Vec<AssetEntry>,
}

impl AssetEntryListResult {
    pub fn new(entries: Vec<AssetEntry>) -> Self {
        AssetEntryListResult { entries }
    }
}

const ASSET_ENTRY_LIST_RESULT_FIELDS: &[&str] = &["entries"];
impl AssetEntryListResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetEntryListResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetEntryListResult>, V::Error> {
        let mut field_entries = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "entries" => {
                    if field_entries.is_some() {
                        return Err(::serde::de::Error::duplicate_field("entries"));
                    }
                    field_entries = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetEntryListResult {
            entries: field_entries.ok_or_else(|| ::serde::de::Error::missing_field("entries"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("entries", &self.entries)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntryListResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetEntryListResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntryListResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetEntryListResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetEntryListResult",
            ASSET_ENTRY_LIST_RESULT_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetEntryListResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetEntryListResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetEntryOp {
    Add,
    /// Functionally the same as an add, but indicates it was forked from another asset chain due to
    /// conflict-policy.
    Fork,
    Edit,
    Push,
    Delete,
    /// Metadata for asset was added, modified, or removed.
    Metadata,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntryOp {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetEntryOp;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntryOp structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "add" => AssetEntryOp::Add,
                    "fork" => AssetEntryOp::Fork,
                    "edit" => AssetEntryOp::Edit,
                    "push" => AssetEntryOp::Push,
                    "delete" => AssetEntryOp::Delete,
                    "metadata" => AssetEntryOp::Metadata,
                    _ => AssetEntryOp::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["add", "fork", "edit", "push", "delete", "metadata", "other"];
        deserializer.deserialize_struct("AssetEntryOp", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetEntryOp {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetEntryOp::Add => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryOp", 1)?;
                s.serialize_field(".tag", "add")?;
                s.end()
            }
            AssetEntryOp::Fork => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryOp", 1)?;
                s.serialize_field(".tag", "fork")?;
                s.end()
            }
            AssetEntryOp::Edit => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryOp", 1)?;
                s.serialize_field(".tag", "edit")?;
                s.end()
            }
            AssetEntryOp::Push => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryOp", 1)?;
                s.serialize_field(".tag", "push")?;
                s.end()
            }
            AssetEntryOp::Delete => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryOp", 1)?;
                s.serialize_field(".tag", "delete")?;
                s.end()
            }
            AssetEntryOp::Metadata => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryOp", 1)?;
                s.serialize_field(".tag", "metadata")?;
                s.end()
            }
            AssetEntryOp::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetEntrySearchArg {
    pub q: String,
    pub asset_pool_path: Option<String>,
}

impl AssetEntrySearchArg {
    pub fn new(q: String) -> Self {
        AssetEntrySearchArg {
            q,
            asset_pool_path: None,
        }
    }

    pub fn with_asset_pool_path(mut self, value: String) -> Self {
        self.asset_pool_path = Some(value);
        self
    }
}

const ASSET_ENTRY_SEARCH_ARG_FIELDS: &[&str] = &["q", "asset_pool_path"];
impl AssetEntrySearchArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetEntrySearchArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetEntrySearchArg>, V::Error> {
        let mut field_q = None;
        let mut field_asset_pool_path = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "q" => {
                    if field_q.is_some() {
                        return Err(::serde::de::Error::duplicate_field("q"));
                    }
                    field_q = Some(map.next_value()?);
                }
                "asset_pool_path" => {
                    if field_asset_pool_path.is_some() {
                        return Err(::serde::de::Error::duplicate_field("asset_pool_path"));
                    }
                    field_asset_pool_path = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetEntrySearchArg {
            q: field_q.ok_or_else(|| ::serde::de::Error::missing_field("q"))?,
            asset_pool_path: field_asset_pool_path.and_then(Option::flatten),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("q", &self.q)?;
        if let Some(val) = &self.asset_pool_path {
            s.serialize_field("asset_pool_path", val)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntrySearchArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetEntrySearchArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntrySearchArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetEntrySearchArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetEntrySearchArg",
            ASSET_ENTRY_SEARCH_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetEntrySearchArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetEntrySearchArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetEntrySearchError {
    BadAssetPoolPath,
    NoPermission,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntrySearchError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetEntrySearchError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntrySearchError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_asset_pool_path" => AssetEntrySearchError::BadAssetPoolPath,
                    "no_permission" => AssetEntrySearchError::NoPermission,
                    _ => AssetEntrySearchError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["bad_asset_pool_path", "no_permission", "other"];
        deserializer.deserialize_struct("AssetEntrySearchError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetEntrySearchError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetEntrySearchError::BadAssetPoolPath => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntrySearchError", 1)?;
                s.serialize_field(".tag", "bad_asset_pool_path")?;
                s.end()
            }
            AssetEntrySearchError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntrySearchError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetEntrySearchError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetEntrySearchError {}

impl ::std::fmt::Display for AssetEntrySearchError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetEntrySearchResult {
    pub semantic_matches: Vec<AssetEntry>,
}

impl AssetEntrySearchResult {
    pub fn new(semantic_matches: Vec<AssetEntry>) -> Self {
        AssetEntrySearchResult { semantic_matches }
    }
}

const ASSET_ENTRY_SEARCH_RESULT_FIELDS: &[&str] = &["semantic_matches"];
impl AssetEntrySearchResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetEntrySearchResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetEntrySearchResult>, V::Error> {
        let mut field_semantic_matches = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "semantic_matches" => {
                    if field_semantic_matches.is_some() {
                        return Err(::serde::de::Error::duplicate_field("semantic_matches"));
                    }
                    field_semantic_matches = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetEntrySearchResult {
            semantic_matches: field_semantic_matches
                .ok_or_else(|| ::serde::de::Error::missing_field("semantic_matches"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("semantic_matches", &self.semantic_matches)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntrySearchResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetEntrySearchResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntrySearchResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetEntrySearchResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetEntrySearchResult",
            ASSET_ENTRY_SEARCH_RESULT_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetEntrySearchResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetEntrySearchResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetGetArg {
    pub name: String,
}

impl AssetGetArg {
    pub fn new(name: String) -> Self {
        AssetGetArg { name }
    }
}

const ASSET_GET_ARG_FIELDS: &[&str] = &["name"];
impl AssetGetArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetGetArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetGetArg>, V::Error> {
        let mut field_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "name" => {
                    if field_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetGetArg {
            name: field_name.ok_or_else(|| ::serde::de::Error::missing_field("name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("name", &self.name)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetGetArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetGetArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetGetArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetGetArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AssetGetArg", ASSET_GET_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AssetGetArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetGetArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetGetError {
    BadName,
    NoPermission,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetGetError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetGetError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetGetError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_name" => AssetGetError::BadName,
                    "no_permission" => AssetGetError::NoPermission,
                    _ => AssetGetError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["bad_name", "no_permission", "other"];
        deserializer.deserialize_struct("AssetGetError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetGetError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetGetError::BadName => {
                // unit
                let mut s = serializer.serialize_struct("AssetGetError", 1)?;
                s.serialize_field(".tag", "bad_name")?;
                s.end()
            }
            AssetGetError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetGetError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetGetError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetGetError {}

impl ::std::fmt::Display for AssetGetError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetGetResult {
    pub entry: AssetEntry,
    pub data_url: String,
    pub metadata_url: Option<String>,
}

impl AssetGetResult {
    pub fn new(entry: AssetEntry, data_url: String) -> Self {
        AssetGetResult {
            entry,
            data_url,
            metadata_url: None,
        }
    }

    pub fn with_metadata_url(mut self, value: String) -> Self {
        self.metadata_url = Some(value);
        self
    }
}

const ASSET_GET_RESULT_FIELDS: &[&str] = &["entry", "data_url", "metadata_url"];
impl AssetGetResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetGetResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetGetResult>, V::Error> {
        let mut field_entry = None;
        let mut field_data_url = None;
        let mut field_metadata_url = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "entry" => {
                    if field_entry.is_some() {
                        return Err(::serde::de::Error::duplicate_field("entry"));
                    }
                    field_entry = Some(map.next_value()?);
                }
                "data_url" => {
                    if field_data_url.is_some() {
                        return Err(::serde::de::Error::duplicate_field("data_url"));
                    }
                    field_data_url = Some(map.next_value()?);
                }
                "metadata_url" => {
                    if field_metadata_url.is_some() {
                        return Err(::serde::de::Error::duplicate_field("metadata_url"));
                    }
                    field_metadata_url = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetGetResult {
            entry: field_entry.ok_or_else(|| ::serde::de::Error::missing_field("entry"))?,
            data_url: field_data_url
                .ok_or_else(|| ::serde::de::Error::missing_field("data_url"))?,
            metadata_url: field_metadata_url.and_then(Option::flatten),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("entry", &self.entry)?;
        s.serialize_field("data_url", &self.data_url)?;
        if let Some(val) = &self.metadata_url {
            s.serialize_field("metadata_url", val)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetGetResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetGetResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetGetResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetGetResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AssetGetResult", ASSET_GET_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AssetGetResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetGetResult", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetInfo {
    pub rev_id: String,
    pub created_by: AssetCreatedBy,
    /// Number of bytes. Deleted assets have a size of 0.
    pub size: u64,
}

impl AssetInfo {
    pub fn new(rev_id: String, created_by: AssetCreatedBy, size: u64) -> Self {
        AssetInfo {
            rev_id,
            created_by,
            size,
        }
    }
}

const ASSET_INFO_FIELDS: &[&str] = &["rev_id", "created_by", "size"];
impl AssetInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetInfo, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetInfo>, V::Error> {
        let mut field_rev_id = None;
        let mut field_created_by = None;
        let mut field_size = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "rev_id" => {
                    if field_rev_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("rev_id"));
                    }
                    field_rev_id = Some(map.next_value()?);
                }
                "created_by" => {
                    if field_created_by.is_some() {
                        return Err(::serde::de::Error::duplicate_field("created_by"));
                    }
                    field_created_by = Some(map.next_value()?);
                }
                "size" => {
                    if field_size.is_some() {
                        return Err(::serde::de::Error::duplicate_field("size"));
                    }
                    field_size = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetInfo {
            rev_id: field_rev_id.ok_or_else(|| ::serde::de::Error::missing_field("rev_id"))?,
            created_by: field_created_by
                .ok_or_else(|| ::serde::de::Error::missing_field("created_by"))?,
            size: field_size.ok_or_else(|| ::serde::de::Error::missing_field("size"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("rev_id", &self.rev_id)?;
        s.serialize_field("created_by", &self.created_by)?;
        s.serialize_field("size", &self.size)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AssetInfo", ASSET_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AssetInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetInfo", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetMetadataInfo {
    pub rev_id: String,
    pub created_by: AssetCreatedBy,
    /// Number of bytes. Deleted assets have a size of 0.
    pub size: u64,
    /// If the metadata specified a `title` key with string value, this is a reproduction of it
    /// truncated to 64-chars.
    pub title: Option<String>,
}

impl AssetMetadataInfo {
    pub fn new(rev_id: String, created_by: AssetCreatedBy, size: u64) -> Self {
        AssetMetadataInfo {
            rev_id,
            created_by,
            size,
            title: None,
        }
    }

    pub fn with_title(mut self, value: String) -> Self {
        self.title = Some(value);
        self
    }
}

const ASSET_METADATA_INFO_FIELDS: &[&str] = &["rev_id", "created_by", "size", "title"];
impl AssetMetadataInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetMetadataInfo, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetMetadataInfo>, V::Error> {
        let mut field_rev_id = None;
        let mut field_created_by = None;
        let mut field_size = None;
        let mut field_title = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "rev_id" => {
                    if field_rev_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("rev_id"));
                    }
                    field_rev_id = Some(map.next_value()?);
                }
                "created_by" => {
                    if field_created_by.is_some() {
                        return Err(::serde::de::Error::duplicate_field("created_by"));
                    }
                    field_created_by = Some(map.next_value()?);
                }
                "size" => {
                    if field_size.is_some() {
                        return Err(::serde::de::Error::duplicate_field("size"));
                    }
                    field_size = Some(map.next_value()?);
                }
                "title" => {
                    if field_title.is_some() {
                        return Err(::serde::de::Error::duplicate_field("title"));
                    }
                    field_title = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetMetadataInfo {
            rev_id: field_rev_id.ok_or_else(|| ::serde::de::Error::missing_field("rev_id"))?,
            created_by: field_created_by
                .ok_or_else(|| ::serde::de::Error::missing_field("created_by"))?,
            size: field_size.ok_or_else(|| ::serde::de::Error::missing_field("size"))?,
            title: field_title.and_then(Option::flatten),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("rev_id", &self.rev_id)?;
        s.serialize_field("created_by", &self.created_by)?;
        s.serialize_field("size", &self.size)?;
        if let Some(val) = &self.title {
            s.serialize_field("title", val)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetMetadataInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetMetadataInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetMetadataInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetMetadataInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetMetadataInfo",
            ASSET_METADATA_INFO_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetMetadataInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetMetadataInfo", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetMetadataPutArg {
    pub name: String,
    /// Must be JSON
    pub data: String,
    pub conflict_policy: PutConflictPolicy,
}

impl AssetMetadataPutArg {
    pub fn new(name: String, data: String) -> Self {
        AssetMetadataPutArg {
            name,
            data,
            conflict_policy: PutConflictPolicy::Override,
        }
    }

    pub fn with_conflict_policy(mut self, value: PutConflictPolicy) -> Self {
        self.conflict_policy = value;
        self
    }
}

const ASSET_METADATA_PUT_ARG_FIELDS: &[&str] = &["name", "data", "conflict_policy"];
impl AssetMetadataPutArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetMetadataPutArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetMetadataPutArg>, V::Error> {
        let mut field_name = None;
        let mut field_data = None;
        let mut field_conflict_policy = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "name" => {
                    if field_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "data" => {
                    if field_data.is_some() {
                        return Err(::serde::de::Error::duplicate_field("data"));
                    }
                    field_data = Some(map.next_value()?);
                }
                "conflict_policy" => {
                    if field_conflict_policy.is_some() {
                        return Err(::serde::de::Error::duplicate_field("conflict_policy"));
                    }
                    field_conflict_policy = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetMetadataPutArg {
            name: field_name.ok_or_else(|| ::serde::de::Error::missing_field("name"))?,
            data: field_data.ok_or_else(|| ::serde::de::Error::missing_field("data"))?,
            conflict_policy: field_conflict_policy.unwrap_or(PutConflictPolicy::Override),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("data", &self.data)?;
        if self.conflict_policy != PutConflictPolicy::Override {
            s.serialize_field("conflict_policy", &self.conflict_policy)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetMetadataPutArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetMetadataPutArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetMetadataPutArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetMetadataPutArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetMetadataPutArg",
            ASSET_METADATA_PUT_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetMetadataPutArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetMetadataPutArg", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetMetadataPutError {
    BadName,
    NoPermission,
    /// Only returned if conflict policy is set to reject.
    Conflict,
    OverQuota,
    /// Metadata must be valid JSON.
    BadMetadata,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetMetadataPutError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetMetadataPutError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetMetadataPutError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_name" => AssetMetadataPutError::BadName,
                    "no_permission" => AssetMetadataPutError::NoPermission,
                    "conflict" => AssetMetadataPutError::Conflict,
                    "over_quota" => AssetMetadataPutError::OverQuota,
                    "bad_metadata" => AssetMetadataPutError::BadMetadata,
                    _ => AssetMetadataPutError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &[
            "bad_name",
            "no_permission",
            "conflict",
            "over_quota",
            "bad_metadata",
            "other",
        ];
        deserializer.deserialize_struct("AssetMetadataPutError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetMetadataPutError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetMetadataPutError::BadName => {
                // unit
                let mut s = serializer.serialize_struct("AssetMetadataPutError", 1)?;
                s.serialize_field(".tag", "bad_name")?;
                s.end()
            }
            AssetMetadataPutError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetMetadataPutError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetMetadataPutError::Conflict => {
                // unit
                let mut s = serializer.serialize_struct("AssetMetadataPutError", 1)?;
                s.serialize_field(".tag", "conflict")?;
                s.end()
            }
            AssetMetadataPutError::OverQuota => {
                // unit
                let mut s = serializer.serialize_struct("AssetMetadataPutError", 1)?;
                s.serialize_field(".tag", "over_quota")?;
                s.end()
            }
            AssetMetadataPutError::BadMetadata => {
                // unit
                let mut s = serializer.serialize_struct("AssetMetadataPutError", 1)?;
                s.serialize_field(".tag", "bad_metadata")?;
                s.end()
            }
            AssetMetadataPutError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetMetadataPutError {}

impl ::std::fmt::Display for AssetMetadataPutError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            AssetMetadataPutError::Conflict => {
                f.write_str("Only returned if conflict policy is set to reject.")
            }
            AssetMetadataPutError::BadMetadata => f.write_str("Metadata must be valid JSON."),
            _ => write!(f, "{:?}", *self),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetPoolQuotaGetArg {
    pub mount_point: String,
}

impl AssetPoolQuotaGetArg {
    pub fn new(mount_point: String) -> Self {
        AssetPoolQuotaGetArg { mount_point }
    }
}

const ASSET_POOL_QUOTA_GET_ARG_FIELDS: &[&str] = &["mount_point"];
impl AssetPoolQuotaGetArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetPoolQuotaGetArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetPoolQuotaGetArg>, V::Error> {
        let mut field_mount_point = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "mount_point" => {
                    if field_mount_point.is_some() {
                        return Err(::serde::de::Error::duplicate_field("mount_point"));
                    }
                    field_mount_point = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetPoolQuotaGetArg {
            mount_point: field_mount_point
                .ok_or_else(|| ::serde::de::Error::missing_field("mount_point"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("mount_point", &self.mount_point)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPoolQuotaGetArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetPoolQuotaGetArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPoolQuotaGetArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetPoolQuotaGetArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetPoolQuotaGetArg",
            ASSET_POOL_QUOTA_GET_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetPoolQuotaGetArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetPoolQuotaGetArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetPoolQuotaGetError {
    BadMountPoint,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPoolQuotaGetError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetPoolQuotaGetError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPoolQuotaGetError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_mount_point" => AssetPoolQuotaGetError::BadMountPoint,
                    _ => AssetPoolQuotaGetError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["bad_mount_point", "other"];
        deserializer.deserialize_struct("AssetPoolQuotaGetError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetPoolQuotaGetError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetPoolQuotaGetError::BadMountPoint => {
                // unit
                let mut s = serializer.serialize_struct("AssetPoolQuotaGetError", 1)?;
                s.serialize_field(".tag", "bad_mount_point")?;
                s.end()
            }
            AssetPoolQuotaGetError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetPoolQuotaGetError {}

impl ::std::fmt::Display for AssetPoolQuotaGetError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetPoolQuotaGetResult {
    pub active_count: u64,
    pub active_size: u64,
    pub total_count: u64,
    pub total_size: u64,
}

impl AssetPoolQuotaGetResult {
    pub fn new(active_count: u64, active_size: u64, total_count: u64, total_size: u64) -> Self {
        AssetPoolQuotaGetResult {
            active_count,
            active_size,
            total_count,
            total_size,
        }
    }
}

const ASSET_POOL_QUOTA_GET_RESULT_FIELDS: &[&str] =
    &["active_count", "active_size", "total_count", "total_size"];
impl AssetPoolQuotaGetResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetPoolQuotaGetResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetPoolQuotaGetResult>, V::Error> {
        let mut field_active_count = None;
        let mut field_active_size = None;
        let mut field_total_count = None;
        let mut field_total_size = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "active_count" => {
                    if field_active_count.is_some() {
                        return Err(::serde::de::Error::duplicate_field("active_count"));
                    }
                    field_active_count = Some(map.next_value()?);
                }
                "active_size" => {
                    if field_active_size.is_some() {
                        return Err(::serde::de::Error::duplicate_field("active_size"));
                    }
                    field_active_size = Some(map.next_value()?);
                }
                "total_count" => {
                    if field_total_count.is_some() {
                        return Err(::serde::de::Error::duplicate_field("total_count"));
                    }
                    field_total_count = Some(map.next_value()?);
                }
                "total_size" => {
                    if field_total_size.is_some() {
                        return Err(::serde::de::Error::duplicate_field("total_size"));
                    }
                    field_total_size = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetPoolQuotaGetResult {
            active_count: field_active_count
                .ok_or_else(|| ::serde::de::Error::missing_field("active_count"))?,
            active_size: field_active_size
                .ok_or_else(|| ::serde::de::Error::missing_field("active_size"))?,
            total_count: field_total_count
                .ok_or_else(|| ::serde::de::Error::missing_field("total_count"))?,
            total_size: field_total_size
                .ok_or_else(|| ::serde::de::Error::missing_field("total_size"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("active_count", &self.active_count)?;
        s.serialize_field("active_size", &self.active_size)?;
        s.serialize_field("total_count", &self.total_count)?;
        s.serialize_field("total_size", &self.total_size)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPoolQuotaGetResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetPoolQuotaGetResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPoolQuotaGetResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetPoolQuotaGetResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetPoolQuotaGetResult",
            ASSET_POOL_QUOTA_GET_RESULT_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetPoolQuotaGetResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetPoolQuotaGetResult", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetPushArg {
    pub name: String,
    pub data: Vec<u8>,
}

impl AssetPushArg {
    pub fn new(name: String, data: Vec<u8>) -> Self {
        AssetPushArg { name, data }
    }
}

const ASSET_PUSH_ARG_FIELDS: &[&str] = &["name", "data"];
impl AssetPushArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetPushArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetPushArg>, V::Error> {
        let mut field_name = None;
        let mut field_data = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "name" => {
                    if field_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "data" => {
                    if field_data.is_some() {
                        return Err(::serde::de::Error::duplicate_field("data"));
                    }
                    field_data = Some(
                        BASE64
                            .decode(map.next_value::<String>()?.as_bytes())
                            .map_err(::serde::de::Error::custom)?,
                    );
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetPushArg {
            name: field_name.ok_or_else(|| ::serde::de::Error::missing_field("name"))?,
            data: field_data.ok_or_else(|| ::serde::de::Error::missing_field("data"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("data", &BASE64.encode(&self.data))?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPushArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetPushArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPushArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetPushArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AssetPushArg", ASSET_PUSH_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AssetPushArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetPushArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetPushError {
    BadName,
    NoPermission,
    OverQuota,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPushError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetPushError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPushError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_name" => AssetPushError::BadName,
                    "no_permission" => AssetPushError::NoPermission,
                    "over_quota" => AssetPushError::OverQuota,
                    _ => AssetPushError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["bad_name", "no_permission", "over_quota", "other"];
        deserializer.deserialize_struct("AssetPushError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetPushError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetPushError::BadName => {
                // unit
                let mut s = serializer.serialize_struct("AssetPushError", 1)?;
                s.serialize_field(".tag", "bad_name")?;
                s.end()
            }
            AssetPushError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetPushError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetPushError::OverQuota => {
                // unit
                let mut s = serializer.serialize_struct("AssetPushError", 1)?;
                s.serialize_field(".tag", "over_quota")?;
                s.end()
            }
            AssetPushError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetPushError {}

impl ::std::fmt::Display for AssetPushError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetPushResult {
    pub entry: AssetEntry,
}

impl AssetPushResult {
    pub fn new(entry: AssetEntry) -> Self {
        AssetPushResult { entry }
    }
}

const ASSET_PUSH_RESULT_FIELDS: &[&str] = &["entry"];
impl AssetPushResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetPushResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetPushResult>, V::Error> {
        let mut field_entry = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "entry" => {
                    if field_entry.is_some() {
                        return Err(::serde::de::Error::duplicate_field("entry"));
                    }
                    field_entry = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetPushResult {
            entry: field_entry.ok_or_else(|| ::serde::de::Error::missing_field("entry"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("entry", &self.entry)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPushResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetPushResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPushResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetPushResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AssetPushResult", ASSET_PUSH_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AssetPushResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetPushResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetPushTextArg {
    pub name: String,
    pub data: String,
}

impl AssetPushTextArg {
    pub fn new(name: String, data: String) -> Self {
        AssetPushTextArg { name, data }
    }
}

const ASSET_PUSH_TEXT_ARG_FIELDS: &[&str] = &["name", "data"];
impl AssetPushTextArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetPushTextArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetPushTextArg>, V::Error> {
        let mut field_name = None;
        let mut field_data = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "name" => {
                    if field_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "data" => {
                    if field_data.is_some() {
                        return Err(::serde::de::Error::duplicate_field("data"));
                    }
                    field_data = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetPushTextArg {
            name: field_name.ok_or_else(|| ::serde::de::Error::missing_field("name"))?,
            data: field_data.ok_or_else(|| ::serde::de::Error::missing_field("data"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("data", &self.data)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPushTextArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetPushTextArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPushTextArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetPushTextArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetPushTextArg",
            ASSET_PUSH_TEXT_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetPushTextArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetPushTextArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetPutArg {
    pub name: String,
    pub data: Vec<u8>,
    pub conflict_policy: PutConflictPolicy,
}

impl AssetPutArg {
    pub fn new(name: String, data: Vec<u8>) -> Self {
        AssetPutArg {
            name,
            data,
            conflict_policy: PutConflictPolicy::Override,
        }
    }

    pub fn with_conflict_policy(mut self, value: PutConflictPolicy) -> Self {
        self.conflict_policy = value;
        self
    }
}

const ASSET_PUT_ARG_FIELDS: &[&str] = &["name", "data", "conflict_policy"];
impl AssetPutArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetPutArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetPutArg>, V::Error> {
        let mut field_name = None;
        let mut field_data = None;
        let mut field_conflict_policy = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "name" => {
                    if field_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "data" => {
                    if field_data.is_some() {
                        return Err(::serde::de::Error::duplicate_field("data"));
                    }
                    field_data = Some(
                        BASE64
                            .decode(map.next_value::<String>()?.as_bytes())
                            .map_err(::serde::de::Error::custom)?,
                    );
                }
                "conflict_policy" => {
                    if field_conflict_policy.is_some() {
                        return Err(::serde::de::Error::duplicate_field("conflict_policy"));
                    }
                    field_conflict_policy = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetPutArg {
            name: field_name.ok_or_else(|| ::serde::de::Error::missing_field("name"))?,
            data: field_data.ok_or_else(|| ::serde::de::Error::missing_field("data"))?,
            conflict_policy: field_conflict_policy.unwrap_or(PutConflictPolicy::Override),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("data", &BASE64.encode(&self.data))?;
        if self.conflict_policy != PutConflictPolicy::Override {
            s.serialize_field("conflict_policy", &self.conflict_policy)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPutArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetPutArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPutArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetPutArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AssetPutArg", ASSET_PUT_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AssetPutArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetPutArg", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetPutError {
    BadName,
    NoPermission,
    /// Only returned if conflict policy is set to reject.
    NameConflict,
    OverQuota,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPutError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetPutError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPutError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_name" => AssetPutError::BadName,
                    "no_permission" => AssetPutError::NoPermission,
                    "name_conflict" => AssetPutError::NameConflict,
                    "over_quota" => AssetPutError::OverQuota,
                    _ => AssetPutError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &[
            "bad_name",
            "no_permission",
            "name_conflict",
            "over_quota",
            "other",
        ];
        deserializer.deserialize_struct("AssetPutError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetPutError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetPutError::BadName => {
                // unit
                let mut s = serializer.serialize_struct("AssetPutError", 1)?;
                s.serialize_field(".tag", "bad_name")?;
                s.end()
            }
            AssetPutError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetPutError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetPutError::NameConflict => {
                // unit
                let mut s = serializer.serialize_struct("AssetPutError", 1)?;
                s.serialize_field(".tag", "name_conflict")?;
                s.end()
            }
            AssetPutError::OverQuota => {
                // unit
                let mut s = serializer.serialize_struct("AssetPutError", 1)?;
                s.serialize_field(".tag", "over_quota")?;
                s.end()
            }
            AssetPutError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetPutError {}

impl ::std::fmt::Display for AssetPutError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            AssetPutError::NameConflict => {
                f.write_str("Only returned if conflict policy is set to reject.")
            }
            _ => write!(f, "{:?}", *self),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetPutResult {
    pub entry: AssetEntry,
}

impl AssetPutResult {
    pub fn new(entry: AssetEntry) -> Self {
        AssetPutResult { entry }
    }
}

const ASSET_PUT_RESULT_FIELDS: &[&str] = &["entry"];
impl AssetPutResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetPutResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetPutResult>, V::Error> {
        let mut field_entry = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "entry" => {
                    if field_entry.is_some() {
                        return Err(::serde::de::Error::duplicate_field("entry"));
                    }
                    field_entry = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetPutResult {
            entry: field_entry.ok_or_else(|| ::serde::de::Error::missing_field("entry"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("entry", &self.entry)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPutResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetPutResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPutResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetPutResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AssetPutResult", ASSET_PUT_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AssetPutResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetPutResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetPutTextArg {
    pub name: String,
    pub data: String,
    pub conflict_policy: PutConflictPolicy,
}

impl AssetPutTextArg {
    pub fn new(name: String, data: String) -> Self {
        AssetPutTextArg {
            name,
            data,
            conflict_policy: PutConflictPolicy::Override,
        }
    }

    pub fn with_conflict_policy(mut self, value: PutConflictPolicy) -> Self {
        self.conflict_policy = value;
        self
    }
}

const ASSET_PUT_TEXT_ARG_FIELDS: &[&str] = &["name", "data", "conflict_policy"];
impl AssetPutTextArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetPutTextArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetPutTextArg>, V::Error> {
        let mut field_name = None;
        let mut field_data = None;
        let mut field_conflict_policy = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "name" => {
                    if field_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "data" => {
                    if field_data.is_some() {
                        return Err(::serde::de::Error::duplicate_field("data"));
                    }
                    field_data = Some(map.next_value()?);
                }
                "conflict_policy" => {
                    if field_conflict_policy.is_some() {
                        return Err(::serde::de::Error::duplicate_field("conflict_policy"));
                    }
                    field_conflict_policy = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetPutTextArg {
            name: field_name.ok_or_else(|| ::serde::de::Error::missing_field("name"))?,
            data: field_data.ok_or_else(|| ::serde::de::Error::missing_field("data"))?,
            conflict_policy: field_conflict_policy.unwrap_or(PutConflictPolicy::Override),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("data", &self.data)?;
        if self.conflict_policy != PutConflictPolicy::Override {
            s.serialize_field("conflict_policy", &self.conflict_policy)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPutTextArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetPutTextArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPutTextArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetPutTextArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AssetPutTextArg", ASSET_PUT_TEXT_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AssetPutTextArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetPutTextArg", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetRemoveArg {
    pub name: String,
}

impl AssetRemoveArg {
    pub fn new(name: String) -> Self {
        AssetRemoveArg { name }
    }
}

const ASSET_REMOVE_ARG_FIELDS: &[&str] = &["name"];
impl AssetRemoveArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetRemoveArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetRemoveArg>, V::Error> {
        let mut field_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "name" => {
                    if field_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetRemoveArg {
            name: field_name.ok_or_else(|| ::serde::de::Error::missing_field("name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("name", &self.name)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetRemoveArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetRemoveArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetRemoveArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetRemoveArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AssetRemoveArg", ASSET_REMOVE_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AssetRemoveArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetRemoveArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetRemoveError {
    BadName,
    NoPermission,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetRemoveError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetRemoveError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetRemoveError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_name" => AssetRemoveError::BadName,
                    "no_permission" => AssetRemoveError::NoPermission,
                    _ => AssetRemoveError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["bad_name", "no_permission", "other"];
        deserializer.deserialize_struct("AssetRemoveError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetRemoveError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetRemoveError::BadName => {
                // unit
                let mut s = serializer.serialize_struct("AssetRemoveError", 1)?;
                s.serialize_field(".tag", "bad_name")?;
                s.end()
            }
            AssetRemoveError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetRemoveError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetRemoveError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetRemoveError {}

impl ::std::fmt::Display for AssetRemoveError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetRemoveResult {
    pub entry: AssetEntry,
}

impl AssetRemoveResult {
    pub fn new(entry: AssetEntry) -> Self {
        AssetRemoveResult { entry }
    }
}

const ASSET_REMOVE_RESULT_FIELDS: &[&str] = &["entry"];
impl AssetRemoveResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetRemoveResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetRemoveResult>, V::Error> {
        let mut field_entry = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "entry" => {
                    if field_entry.is_some() {
                        return Err(::serde::de::Error::duplicate_field("entry"));
                    }
                    field_entry = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetRemoveResult {
            entry: field_entry.ok_or_else(|| ::serde::de::Error::missing_field("entry"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("entry", &self.entry)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetRemoveResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetRemoveResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetRemoveResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetRemoveResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetRemoveResult",
            ASSET_REMOVE_RESULT_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetRemoveResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetRemoveResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetReplaceArg {
    pub entry_id: String,
    pub data: Vec<u8>,
    pub rev_id: Option<String>,
    pub conflict_policy: ReplaceConflictPolicy,
}

impl AssetReplaceArg {
    pub fn new(entry_id: String, data: Vec<u8>) -> Self {
        AssetReplaceArg {
            entry_id,
            data,
            rev_id: None,
            conflict_policy: ReplaceConflictPolicy::Reject,
        }
    }

    pub fn with_rev_id(mut self, value: String) -> Self {
        self.rev_id = Some(value);
        self
    }

    pub fn with_conflict_policy(mut self, value: ReplaceConflictPolicy) -> Self {
        self.conflict_policy = value;
        self
    }
}

const ASSET_REPLACE_ARG_FIELDS: &[&str] = &["entry_id", "data", "rev_id", "conflict_policy"];
impl AssetReplaceArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetReplaceArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetReplaceArg>, V::Error> {
        let mut field_entry_id = None;
        let mut field_data = None;
        let mut field_rev_id = None;
        let mut field_conflict_policy = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "entry_id" => {
                    if field_entry_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("entry_id"));
                    }
                    field_entry_id = Some(map.next_value()?);
                }
                "data" => {
                    if field_data.is_some() {
                        return Err(::serde::de::Error::duplicate_field("data"));
                    }
                    field_data = Some(
                        BASE64
                            .decode(map.next_value::<String>()?.as_bytes())
                            .map_err(::serde::de::Error::custom)?,
                    );
                }
                "rev_id" => {
                    if field_rev_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("rev_id"));
                    }
                    field_rev_id = Some(map.next_value()?);
                }
                "conflict_policy" => {
                    if field_conflict_policy.is_some() {
                        return Err(::serde::de::Error::duplicate_field("conflict_policy"));
                    }
                    field_conflict_policy = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetReplaceArg {
            entry_id: field_entry_id
                .ok_or_else(|| ::serde::de::Error::missing_field("entry_id"))?,
            data: field_data.ok_or_else(|| ::serde::de::Error::missing_field("data"))?,
            rev_id: field_rev_id.and_then(Option::flatten),
            conflict_policy: field_conflict_policy.unwrap_or(ReplaceConflictPolicy::Reject),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("entry_id", &self.entry_id)?;
        s.serialize_field("data", &BASE64.encode(&self.data))?;
        if let Some(val) = &self.rev_id {
            s.serialize_field("rev_id", val)?;
        }
        if self.conflict_policy != ReplaceConflictPolicy::Reject {
            s.serialize_field("conflict_policy", &self.conflict_policy)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetReplaceArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetReplaceArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetReplaceArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetReplaceArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AssetReplaceArg", ASSET_REPLACE_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AssetReplaceArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetReplaceArg", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetReplaceError {
    BadEntryId,
    NoPermission,
    BadRevId,
    /// Revision ID is no longer the most recent for the asset.
    OldRevId,
    OverQuota,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetReplaceError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetReplaceError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetReplaceError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_entry_id" => AssetReplaceError::BadEntryId,
                    "no_permission" => AssetReplaceError::NoPermission,
                    "bad_rev_id" => AssetReplaceError::BadRevId,
                    "old_rev_id" => AssetReplaceError::OldRevId,
                    "over_quota" => AssetReplaceError::OverQuota,
                    _ => AssetReplaceError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &[
            "bad_entry_id",
            "no_permission",
            "bad_rev_id",
            "old_rev_id",
            "over_quota",
            "other",
        ];
        deserializer.deserialize_struct("AssetReplaceError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetReplaceError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetReplaceError::BadEntryId => {
                // unit
                let mut s = serializer.serialize_struct("AssetReplaceError", 1)?;
                s.serialize_field(".tag", "bad_entry_id")?;
                s.end()
            }
            AssetReplaceError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetReplaceError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetReplaceError::BadRevId => {
                // unit
                let mut s = serializer.serialize_struct("AssetReplaceError", 1)?;
                s.serialize_field(".tag", "bad_rev_id")?;
                s.end()
            }
            AssetReplaceError::OldRevId => {
                // unit
                let mut s = serializer.serialize_struct("AssetReplaceError", 1)?;
                s.serialize_field(".tag", "old_rev_id")?;
                s.end()
            }
            AssetReplaceError::OverQuota => {
                // unit
                let mut s = serializer.serialize_struct("AssetReplaceError", 1)?;
                s.serialize_field(".tag", "over_quota")?;
                s.end()
            }
            AssetReplaceError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetReplaceError {}

impl ::std::fmt::Display for AssetReplaceError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            AssetReplaceError::OldRevId => {
                f.write_str("Revision ID is no longer the most recent for the asset.")
            }
            _ => write!(f, "{:?}", *self),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetReplaceResult {
    pub entry: AssetEntry,
}

impl AssetReplaceResult {
    pub fn new(entry: AssetEntry) -> Self {
        AssetReplaceResult { entry }
    }
}

const ASSET_REPLACE_RESULT_FIELDS: &[&str] = &["entry"];
impl AssetReplaceResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetReplaceResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetReplaceResult>, V::Error> {
        let mut field_entry = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "entry" => {
                    if field_entry.is_some() {
                        return Err(::serde::de::Error::duplicate_field("entry"));
                    }
                    field_entry = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetReplaceResult {
            entry: field_entry.ok_or_else(|| ::serde::de::Error::missing_field("entry"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("entry", &self.entry)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetReplaceResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetReplaceResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetReplaceResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetReplaceResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetReplaceResult",
            ASSET_REPLACE_RESULT_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetReplaceResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetReplaceResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetReplaceTextArg {
    pub entry_id: String,
    pub data: String,
    pub rev_id: Option<String>,
    pub conflict_policy: ReplaceConflictPolicy,
}

impl AssetReplaceTextArg {
    pub fn new(entry_id: String, data: String) -> Self {
        AssetReplaceTextArg {
            entry_id,
            data,
            rev_id: None,
            conflict_policy: ReplaceConflictPolicy::Reject,
        }
    }

    pub fn with_rev_id(mut self, value: String) -> Self {
        self.rev_id = Some(value);
        self
    }

    pub fn with_conflict_policy(mut self, value: ReplaceConflictPolicy) -> Self {
        self.conflict_policy = value;
        self
    }
}

const ASSET_REPLACE_TEXT_ARG_FIELDS: &[&str] = &["entry_id", "data", "rev_id", "conflict_policy"];
impl AssetReplaceTextArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetReplaceTextArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetReplaceTextArg>, V::Error> {
        let mut field_entry_id = None;
        let mut field_data = None;
        let mut field_rev_id = None;
        let mut field_conflict_policy = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "entry_id" => {
                    if field_entry_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("entry_id"));
                    }
                    field_entry_id = Some(map.next_value()?);
                }
                "data" => {
                    if field_data.is_some() {
                        return Err(::serde::de::Error::duplicate_field("data"));
                    }
                    field_data = Some(map.next_value()?);
                }
                "rev_id" => {
                    if field_rev_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("rev_id"));
                    }
                    field_rev_id = Some(map.next_value()?);
                }
                "conflict_policy" => {
                    if field_conflict_policy.is_some() {
                        return Err(::serde::de::Error::duplicate_field("conflict_policy"));
                    }
                    field_conflict_policy = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetReplaceTextArg {
            entry_id: field_entry_id
                .ok_or_else(|| ::serde::de::Error::missing_field("entry_id"))?,
            data: field_data.ok_or_else(|| ::serde::de::Error::missing_field("data"))?,
            rev_id: field_rev_id.and_then(Option::flatten),
            conflict_policy: field_conflict_policy.unwrap_or(ReplaceConflictPolicy::Reject),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("entry_id", &self.entry_id)?;
        s.serialize_field("data", &self.data)?;
        if let Some(val) = &self.rev_id {
            s.serialize_field("rev_id", val)?;
        }
        if self.conflict_policy != ReplaceConflictPolicy::Reject {
            s.serialize_field("conflict_policy", &self.conflict_policy)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetReplaceTextArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetReplaceTextArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetReplaceTextArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetReplaceTextArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetReplaceTextArg",
            ASSET_REPLACE_TEXT_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetReplaceTextArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetReplaceTextArg", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetRevision {
    pub op: AssetEntryOp,
    pub asset: AssetInfo,
    pub data_url: Option<String>,
    pub metadata: Option<AssetMetadataInfo>,
    pub metadata_url: Option<String>,
}

impl AssetRevision {
    pub fn new(op: AssetEntryOp, asset: AssetInfo) -> Self {
        AssetRevision {
            op,
            asset,
            data_url: None,
            metadata: None,
            metadata_url: None,
        }
    }

    pub fn with_data_url(mut self, value: String) -> Self {
        self.data_url = Some(value);
        self
    }

    pub fn with_metadata(mut self, value: AssetMetadataInfo) -> Self {
        self.metadata = Some(value);
        self
    }

    pub fn with_metadata_url(mut self, value: String) -> Self {
        self.metadata_url = Some(value);
        self
    }
}

const ASSET_REVISION_FIELDS: &[&str] = &["op", "asset", "data_url", "metadata", "metadata_url"];
impl AssetRevision {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetRevision, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetRevision>, V::Error> {
        let mut field_op = None;
        let mut field_asset = None;
        let mut field_data_url = None;
        let mut field_metadata = None;
        let mut field_metadata_url = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "op" => {
                    if field_op.is_some() {
                        return Err(::serde::de::Error::duplicate_field("op"));
                    }
                    field_op = Some(map.next_value()?);
                }
                "asset" => {
                    if field_asset.is_some() {
                        return Err(::serde::de::Error::duplicate_field("asset"));
                    }
                    field_asset = Some(map.next_value()?);
                }
                "data_url" => {
                    if field_data_url.is_some() {
                        return Err(::serde::de::Error::duplicate_field("data_url"));
                    }
                    field_data_url = Some(map.next_value()?);
                }
                "metadata" => {
                    if field_metadata.is_some() {
                        return Err(::serde::de::Error::duplicate_field("metadata"));
                    }
                    field_metadata = Some(map.next_value()?);
                }
                "metadata_url" => {
                    if field_metadata_url.is_some() {
                        return Err(::serde::de::Error::duplicate_field("metadata_url"));
                    }
                    field_metadata_url = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetRevision {
            op: field_op.ok_or_else(|| ::serde::de::Error::missing_field("op"))?,
            asset: field_asset.ok_or_else(|| ::serde::de::Error::missing_field("asset"))?,
            data_url: field_data_url.and_then(Option::flatten),
            metadata: field_metadata.and_then(Option::flatten),
            metadata_url: field_metadata_url.and_then(Option::flatten),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("op", &self.op)?;
        s.serialize_field("asset", &self.asset)?;
        if let Some(val) = &self.data_url {
            s.serialize_field("data_url", val)?;
        }
        if let Some(val) = &self.metadata {
            s.serialize_field("metadata", val)?;
        }
        if let Some(val) = &self.metadata_url {
            s.serialize_field("metadata_url", val)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetRevision {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetRevision;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetRevision struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetRevision::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AssetRevision", ASSET_REVISION_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AssetRevision {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetRevision", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetRevisionCursor {
    pub cursor: String,
    /// If set, the next call will jump to the parent revision-chain that forked into the one that's
    /// been iterating.
    pub is_fork: bool,
}

impl AssetRevisionCursor {
    pub fn new(cursor: String, is_fork: bool) -> Self {
        AssetRevisionCursor { cursor, is_fork }
    }
}

const ASSET_REVISION_CURSOR_FIELDS: &[&str] = &["cursor", "is_fork"];
impl AssetRevisionCursor {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetRevisionCursor, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetRevisionCursor>, V::Error> {
        let mut field_cursor = None;
        let mut field_is_fork = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(::serde::de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                "is_fork" => {
                    if field_is_fork.is_some() {
                        return Err(::serde::de::Error::duplicate_field("is_fork"));
                    }
                    field_is_fork = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetRevisionCursor {
            cursor: field_cursor.ok_or_else(|| ::serde::de::Error::missing_field("cursor"))?,
            is_fork: field_is_fork.ok_or_else(|| ::serde::de::Error::missing_field("is_fork"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("cursor", &self.cursor)?;
        s.serialize_field("is_fork", &self.is_fork)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetRevisionCursor {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetRevisionCursor;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetRevisionCursor struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetRevisionCursor::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetRevisionCursor",
            ASSET_REVISION_CURSOR_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetRevisionCursor {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetRevisionCursor", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetRevisionIterArg {
    pub entry_ref: EntryRef,
    pub limit: u32,
}

impl AssetRevisionIterArg {
    pub fn new(entry_ref: EntryRef) -> Self {
        AssetRevisionIterArg {
            entry_ref,
            limit: 10,
        }
    }

    pub fn with_limit(mut self, value: u32) -> Self {
        self.limit = value;
        self
    }
}

const ASSET_REVISION_ITER_ARG_FIELDS: &[&str] = &["entry_ref", "limit"];
impl AssetRevisionIterArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetRevisionIterArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetRevisionIterArg>, V::Error> {
        let mut field_entry_ref = None;
        let mut field_limit = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "entry_ref" => {
                    if field_entry_ref.is_some() {
                        return Err(::serde::de::Error::duplicate_field("entry_ref"));
                    }
                    field_entry_ref = Some(map.next_value()?);
                }
                "limit" => {
                    if field_limit.is_some() {
                        return Err(::serde::de::Error::duplicate_field("limit"));
                    }
                    field_limit = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetRevisionIterArg {
            entry_ref: field_entry_ref
                .ok_or_else(|| ::serde::de::Error::missing_field("entry_ref"))?,
            limit: field_limit.unwrap_or(10),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("entry_ref", &self.entry_ref)?;
        if self.limit != 10 {
            s.serialize_field("limit", &self.limit)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetRevisionIterArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetRevisionIterArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetRevisionIterArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetRevisionIterArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetRevisionIterArg",
            ASSET_REVISION_ITER_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetRevisionIterArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetRevisionIterArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetRevisionIterError {
    BadEntryRef,
    NoPermission,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetRevisionIterError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetRevisionIterError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetRevisionIterError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_entry_ref" => AssetRevisionIterError::BadEntryRef,
                    "no_permission" => AssetRevisionIterError::NoPermission,
                    _ => AssetRevisionIterError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["bad_entry_ref", "no_permission", "other"];
        deserializer.deserialize_struct("AssetRevisionIterError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetRevisionIterError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetRevisionIterError::BadEntryRef => {
                // unit
                let mut s = serializer.serialize_struct("AssetRevisionIterError", 1)?;
                s.serialize_field(".tag", "bad_entry_ref")?;
                s.end()
            }
            AssetRevisionIterError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetRevisionIterError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetRevisionIterError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetRevisionIterError {}

impl ::std::fmt::Display for AssetRevisionIterError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetRevisionIterNextArg {
    pub cursor: String,
    pub limit: u32,
}

impl AssetRevisionIterNextArg {
    pub fn new(cursor: String) -> Self {
        AssetRevisionIterNextArg { cursor, limit: 10 }
    }

    pub fn with_limit(mut self, value: u32) -> Self {
        self.limit = value;
        self
    }
}

const ASSET_REVISION_ITER_NEXT_ARG_FIELDS: &[&str] = &["cursor", "limit"];
impl AssetRevisionIterNextArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetRevisionIterNextArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetRevisionIterNextArg>, V::Error> {
        let mut field_cursor = None;
        let mut field_limit = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(::serde::de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                "limit" => {
                    if field_limit.is_some() {
                        return Err(::serde::de::Error::duplicate_field("limit"));
                    }
                    field_limit = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetRevisionIterNextArg {
            cursor: field_cursor.ok_or_else(|| ::serde::de::Error::missing_field("cursor"))?,
            limit: field_limit.unwrap_or(10),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("cursor", &self.cursor)?;
        if self.limit != 10 {
            s.serialize_field("limit", &self.limit)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetRevisionIterNextArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetRevisionIterNextArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetRevisionIterNextArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetRevisionIterNextArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetRevisionIterNextArg",
            ASSET_REVISION_ITER_NEXT_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetRevisionIterNextArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetRevisionIterNextArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetRevisionIterNextError {
    BadCursor,
    NoPermission,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetRevisionIterNextError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetRevisionIterNextError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetRevisionIterNextError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_cursor" => AssetRevisionIterNextError::BadCursor,
                    "no_permission" => AssetRevisionIterNextError::NoPermission,
                    _ => AssetRevisionIterNextError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["bad_cursor", "no_permission", "other"];
        deserializer.deserialize_struct("AssetRevisionIterNextError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetRevisionIterNextError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetRevisionIterNextError::BadCursor => {
                // unit
                let mut s = serializer.serialize_struct("AssetRevisionIterNextError", 1)?;
                s.serialize_field(".tag", "bad_cursor")?;
                s.end()
            }
            AssetRevisionIterNextError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetRevisionIterNextError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetRevisionIterNextError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetRevisionIterNextError {}

impl ::std::fmt::Display for AssetRevisionIterNextError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetRevisionIterResult {
    pub revisions: Vec<AssetRevision>,
    /// Approximate number of revisions remaining including those in `revisions`.
    pub approx_remaining: u32,
    pub next: Option<AssetRevisionCursor>,
}

impl AssetRevisionIterResult {
    pub fn new(revisions: Vec<AssetRevision>, approx_remaining: u32) -> Self {
        AssetRevisionIterResult {
            revisions,
            approx_remaining,
            next: None,
        }
    }

    pub fn with_next(mut self, value: AssetRevisionCursor) -> Self {
        self.next = Some(value);
        self
    }
}

const ASSET_REVISION_ITER_RESULT_FIELDS: &[&str] = &["revisions", "approx_remaining", "next"];
impl AssetRevisionIterResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetRevisionIterResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetRevisionIterResult>, V::Error> {
        let mut field_revisions = None;
        let mut field_approx_remaining = None;
        let mut field_next = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "revisions" => {
                    if field_revisions.is_some() {
                        return Err(::serde::de::Error::duplicate_field("revisions"));
                    }
                    field_revisions = Some(map.next_value()?);
                }
                "approx_remaining" => {
                    if field_approx_remaining.is_some() {
                        return Err(::serde::de::Error::duplicate_field("approx_remaining"));
                    }
                    field_approx_remaining = Some(map.next_value()?);
                }
                "next" => {
                    if field_next.is_some() {
                        return Err(::serde::de::Error::duplicate_field("next"));
                    }
                    field_next = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetRevisionIterResult {
            revisions: field_revisions
                .ok_or_else(|| ::serde::de::Error::missing_field("revisions"))?,
            approx_remaining: field_approx_remaining
                .ok_or_else(|| ::serde::de::Error::missing_field("approx_remaining"))?,
            next: field_next.and_then(Option::flatten),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("revisions", &self.revisions)?;
        s.serialize_field("approx_remaining", &self.approx_remaining)?;
        if let Some(val) = &self.next {
            s.serialize_field("next", val)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetRevisionIterResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetRevisionIterResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetRevisionIterResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetRevisionIterResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetRevisionIterResult",
            ASSET_REVISION_ITER_RESULT_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetRevisionIterResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetRevisionIterResult", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum EntryRef {
    Name(String),
    EntryId(String),
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for EntryRef {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = EntryRef;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EntryRef structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "name" => match map.next_key()? {
                        Some("name") => EntryRef::Name(map.next_value()?),
                        None => return Err(de::Error::missing_field("name")),
                        _ => return Err(de::Error::unknown_field(tag, VARIANTS)),
                    },
                    "entry_id" => match map.next_key()? {
                        Some("entry_id") => EntryRef::EntryId(map.next_value()?),
                        None => return Err(de::Error::missing_field("entry_id")),
                        _ => return Err(de::Error::unknown_field(tag, VARIANTS)),
                    },
                    _ => EntryRef::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["name", "entry_id", "other"];
        deserializer.deserialize_struct("EntryRef", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for EntryRef {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            EntryRef::Name(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("EntryRef", 2)?;
                s.serialize_field(".tag", "name")?;
                s.serialize_field("name", x)?;
                s.end()
            }
            EntryRef::EntryId(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("EntryRef", 2)?;
                s.serialize_field(".tag", "entry_id")?;
                s.serialize_field("entry_id", x)?;
                s.end()
            }
            EntryRef::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

/// Policy when the new asset has a [`AssetPutTextArg::name`](AssetPutTextArg) that conflicts with
/// an existing asset.
#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum PutConflictPolicy {
    Reject,
    Override,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for PutConflictPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = PutConflictPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PutConflictPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "reject" => PutConflictPolicy::Reject,
                    "override" => PutConflictPolicy::Override,
                    _ => PutConflictPolicy::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["reject", "override", "other"];
        deserializer.deserialize_struct("PutConflictPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for PutConflictPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            PutConflictPolicy::Reject => {
                // unit
                let mut s = serializer.serialize_struct("PutConflictPolicy", 1)?;
                s.serialize_field(".tag", "reject")?;
                s.end()
            }
            PutConflictPolicy::Override => {
                // unit
                let mut s = serializer.serialize_struct("PutConflictPolicy", 1)?;
                s.serialize_field(".tag", "override")?;
                s.end()
            }
            PutConflictPolicy::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

/// Policy when [`AssetReplaceArg::rev_id`](AssetReplaceArg) is no longer the most recent for the
/// asset.
#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum ReplaceConflictPolicy {
    Reject,
    Fork,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ReplaceConflictPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ReplaceConflictPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ReplaceConflictPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "reject" => ReplaceConflictPolicy::Reject,
                    "fork" => ReplaceConflictPolicy::Fork,
                    _ => ReplaceConflictPolicy::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["reject", "fork", "other"];
        deserializer.deserialize_struct("ReplaceConflictPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ReplaceConflictPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ReplaceConflictPolicy::Reject => {
                // unit
                let mut s = serializer.serialize_struct("ReplaceConflictPolicy", 1)?;
                s.serialize_field(".tag", "reject")?;
                s.end()
            }
            ReplaceConflictPolicy::Fork => {
                // unit
                let mut s = serializer.serialize_struct("ReplaceConflictPolicy", 1)?;
                s.serialize_field(".tag", "fork")?;
                s.end()
            }
            ReplaceConflictPolicy::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}
