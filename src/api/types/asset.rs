// DO NOT EDIT
// This file was @generated by Stone

#![allow(
    dead_code,
    clippy::too_many_arguments,
    clippy::too_many_arguments,
    clippy::large_enum_variant,
    clippy::result_large_err,
    clippy::doc_markdown
)]

#[allow(unused_imports)]
use base64::{Engine as _, engine::general_purpose::STANDARD_NO_PAD as BASE64};

/// Access Control Entry (ACE)
#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AceType {
    Allow,
    Deny,
    Default,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AceType {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AceType;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AceType structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "allow" => AceType::Allow,
                    "deny" => AceType::Deny,
                    "default" => AceType::Default,
                    _ => AceType::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["allow", "deny", "default", "other"];
        deserializer.deserialize_struct("AceType", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AceType {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AceType::Allow => {
                // unit
                let mut s = serializer.serialize_struct("AceType", 1)?;
                s.serialize_field(".tag", "allow")?;
                s.end()
            }
            AceType::Deny => {
                // unit
                let mut s = serializer.serialize_struct("AceType", 1)?;
                s.serialize_field(".tag", "deny")?;
                s.end()
            }
            AceType::Default => {
                // unit
                let mut s = serializer.serialize_struct("AceType", 1)?;
                s.serialize_field(".tag", "default")?;
                s.end()
            }
            AceType::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetCreatedBy {
    User(AssetCreatedByUser),
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetCreatedBy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetCreatedBy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetCreatedBy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "user" => {
                        AssetCreatedBy::User(AssetCreatedByUser::internal_deserialize(&mut map)?)
                    }
                    _ => AssetCreatedBy::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["user", "other"];
        deserializer.deserialize_struct("AssetCreatedBy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetCreatedBy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetCreatedBy::User(ref x) => {
                // struct
                let mut s = serializer.serialize_struct("AssetCreatedBy", 2)?;
                s.serialize_field(".tag", "user")?;
                x.internal_serialize::<S>(&mut s)?;
                s.end()
            }
            AssetCreatedBy::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetCreatedByUser {
    pub username: String,
}

impl AssetCreatedByUser {
    pub fn new(username: String) -> Self {
        AssetCreatedByUser { username }
    }
}

const ASSET_CREATED_BY_USER_FIELDS: &[&str] = &["username"];
impl AssetCreatedByUser {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetCreatedByUser, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetCreatedByUser>, V::Error> {
        let mut field_username = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "username" => {
                    if field_username.is_some() {
                        return Err(::serde::de::Error::duplicate_field("username"));
                    }
                    field_username = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetCreatedByUser {
            username: field_username
                .ok_or_else(|| ::serde::de::Error::missing_field("username"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("username", &self.username)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetCreatedByUser {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetCreatedByUser;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetCreatedByUser struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetCreatedByUser::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetCreatedByUser",
            ASSET_CREATED_BY_USER_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetCreatedByUser {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetCreatedByUser", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetEntry {
    pub entry_id: String,
    pub seq_id: i64,
    pub name: String,
    pub op: AssetEntryOp,
    pub asset: AssetInfo,
    /// The total size of all revisions of a given asset and metadata. This is important because a
    /// user's quota is based on the sum of all revisions.
    pub total_size: u64,
    pub metadata: Option<AssetMetadataInfo>,
}

impl AssetEntry {
    pub fn new(
        entry_id: String,
        seq_id: i64,
        name: String,
        op: AssetEntryOp,
        asset: AssetInfo,
        total_size: u64,
    ) -> Self {
        AssetEntry {
            entry_id,
            seq_id,
            name,
            op,
            asset,
            total_size,
            metadata: None,
        }
    }

    pub fn with_metadata(mut self, value: AssetMetadataInfo) -> Self {
        self.metadata = Some(value);
        self
    }
}

const ASSET_ENTRY_FIELDS: &[&str] = &[
    "entry_id",
    "seq_id",
    "name",
    "op",
    "asset",
    "total_size",
    "metadata",
];
impl AssetEntry {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetEntry, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetEntry>, V::Error> {
        let mut field_entry_id = None;
        let mut field_seq_id = None;
        let mut field_name = None;
        let mut field_op = None;
        let mut field_asset = None;
        let mut field_total_size = None;
        let mut field_metadata = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "entry_id" => {
                    if field_entry_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("entry_id"));
                    }
                    field_entry_id = Some(map.next_value()?);
                }
                "seq_id" => {
                    if field_seq_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("seq_id"));
                    }
                    field_seq_id = Some(map.next_value()?);
                }
                "name" => {
                    if field_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "op" => {
                    if field_op.is_some() {
                        return Err(::serde::de::Error::duplicate_field("op"));
                    }
                    field_op = Some(map.next_value()?);
                }
                "asset" => {
                    if field_asset.is_some() {
                        return Err(::serde::de::Error::duplicate_field("asset"));
                    }
                    field_asset = Some(map.next_value()?);
                }
                "total_size" => {
                    if field_total_size.is_some() {
                        return Err(::serde::de::Error::duplicate_field("total_size"));
                    }
                    field_total_size = Some(map.next_value()?);
                }
                "metadata" => {
                    if field_metadata.is_some() {
                        return Err(::serde::de::Error::duplicate_field("metadata"));
                    }
                    field_metadata = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetEntry {
            entry_id: field_entry_id
                .ok_or_else(|| ::serde::de::Error::missing_field("entry_id"))?,
            seq_id: field_seq_id.ok_or_else(|| ::serde::de::Error::missing_field("seq_id"))?,
            name: field_name.ok_or_else(|| ::serde::de::Error::missing_field("name"))?,
            op: field_op.ok_or_else(|| ::serde::de::Error::missing_field("op"))?,
            asset: field_asset.ok_or_else(|| ::serde::de::Error::missing_field("asset"))?,
            total_size: field_total_size
                .ok_or_else(|| ::serde::de::Error::missing_field("total_size"))?,
            metadata: field_metadata.and_then(Option::flatten),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("entry_id", &self.entry_id)?;
        s.serialize_field("seq_id", &self.seq_id)?;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("op", &self.op)?;
        s.serialize_field("asset", &self.asset)?;
        s.serialize_field("total_size", &self.total_size)?;
        if let Some(val) = &self.metadata {
            s.serialize_field("metadata", val)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntry {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetEntry;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntry struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetEntry::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AssetEntry", ASSET_ENTRY_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AssetEntry {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetEntry", 7)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetEntryAcl {
    pub read_data: AceType,
    pub push_data: AceType,
    pub read_revisions: AceType,
}

impl AssetEntryAcl {
    pub fn new(read_data: AceType, push_data: AceType, read_revisions: AceType) -> Self {
        AssetEntryAcl {
            read_data,
            push_data,
            read_revisions,
        }
    }
}

const ASSET_ENTRY_ACL_FIELDS: &[&str] = &["read_data", "push_data", "read_revisions"];
impl AssetEntryAcl {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetEntryAcl, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetEntryAcl>, V::Error> {
        let mut field_read_data = None;
        let mut field_push_data = None;
        let mut field_read_revisions = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "read_data" => {
                    if field_read_data.is_some() {
                        return Err(::serde::de::Error::duplicate_field("read_data"));
                    }
                    field_read_data = Some(map.next_value()?);
                }
                "push_data" => {
                    if field_push_data.is_some() {
                        return Err(::serde::de::Error::duplicate_field("push_data"));
                    }
                    field_push_data = Some(map.next_value()?);
                }
                "read_revisions" => {
                    if field_read_revisions.is_some() {
                        return Err(::serde::de::Error::duplicate_field("read_revisions"));
                    }
                    field_read_revisions = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetEntryAcl {
            read_data: field_read_data
                .ok_or_else(|| ::serde::de::Error::missing_field("read_data"))?,
            push_data: field_push_data
                .ok_or_else(|| ::serde::de::Error::missing_field("push_data"))?,
            read_revisions: field_read_revisions
                .ok_or_else(|| ::serde::de::Error::missing_field("read_revisions"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("read_data", &self.read_data)?;
        s.serialize_field("push_data", &self.push_data)?;
        s.serialize_field("read_revisions", &self.read_revisions)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntryAcl {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetEntryAcl;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntryAcl struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetEntryAcl::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AssetEntryAcl", ASSET_ENTRY_ACL_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AssetEntryAcl {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetEntryAcl", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetEntryAclGetArg {
    pub entry_ref: EntryRef,
}

impl AssetEntryAclGetArg {
    pub fn new(entry_ref: EntryRef) -> Self {
        AssetEntryAclGetArg { entry_ref }
    }
}

const ASSET_ENTRY_ACL_GET_ARG_FIELDS: &[&str] = &["entry_ref"];
impl AssetEntryAclGetArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetEntryAclGetArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetEntryAclGetArg>, V::Error> {
        let mut field_entry_ref = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "entry_ref" => {
                    if field_entry_ref.is_some() {
                        return Err(::serde::de::Error::duplicate_field("entry_ref"));
                    }
                    field_entry_ref = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetEntryAclGetArg {
            entry_ref: field_entry_ref
                .ok_or_else(|| ::serde::de::Error::missing_field("entry_ref"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("entry_ref", &self.entry_ref)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntryAclGetArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetEntryAclGetArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntryAclGetArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetEntryAclGetArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetEntryAclGetArg",
            ASSET_ENTRY_ACL_GET_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetEntryAclGetArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetEntryAclGetArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetEntryAclGetError {
    BadEntryRef,
    NoPermission,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntryAclGetError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetEntryAclGetError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntryAclGetError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_entry_ref" => AssetEntryAclGetError::BadEntryRef,
                    "no_permission" => AssetEntryAclGetError::NoPermission,
                    _ => AssetEntryAclGetError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["bad_entry_ref", "no_permission", "other"];
        deserializer.deserialize_struct("AssetEntryAclGetError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetEntryAclGetError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetEntryAclGetError::BadEntryRef => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryAclGetError", 1)?;
                s.serialize_field(".tag", "bad_entry_ref")?;
                s.end()
            }
            AssetEntryAclGetError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryAclGetError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetEntryAclGetError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetEntryAclGetError {}

impl ::std::fmt::Display for AssetEntryAclGetError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetEntryAclSetArg {
    pub entry_ref: EntryRef,
    pub read_data: Option<AceType>,
    pub push_data: Option<AceType>,
    pub read_revisions: Option<AceType>,
}

impl AssetEntryAclSetArg {
    pub fn new(entry_ref: EntryRef) -> Self {
        AssetEntryAclSetArg {
            entry_ref,
            read_data: None,
            push_data: None,
            read_revisions: None,
        }
    }

    pub fn with_read_data(mut self, value: AceType) -> Self {
        self.read_data = Some(value);
        self
    }

    pub fn with_push_data(mut self, value: AceType) -> Self {
        self.push_data = Some(value);
        self
    }

    pub fn with_read_revisions(mut self, value: AceType) -> Self {
        self.read_revisions = Some(value);
        self
    }
}

const ASSET_ENTRY_ACL_SET_ARG_FIELDS: &[&str] =
    &["entry_ref", "read_data", "push_data", "read_revisions"];
impl AssetEntryAclSetArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetEntryAclSetArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetEntryAclSetArg>, V::Error> {
        let mut field_entry_ref = None;
        let mut field_read_data = None;
        let mut field_push_data = None;
        let mut field_read_revisions = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "entry_ref" => {
                    if field_entry_ref.is_some() {
                        return Err(::serde::de::Error::duplicate_field("entry_ref"));
                    }
                    field_entry_ref = Some(map.next_value()?);
                }
                "read_data" => {
                    if field_read_data.is_some() {
                        return Err(::serde::de::Error::duplicate_field("read_data"));
                    }
                    field_read_data = Some(map.next_value()?);
                }
                "push_data" => {
                    if field_push_data.is_some() {
                        return Err(::serde::de::Error::duplicate_field("push_data"));
                    }
                    field_push_data = Some(map.next_value()?);
                }
                "read_revisions" => {
                    if field_read_revisions.is_some() {
                        return Err(::serde::de::Error::duplicate_field("read_revisions"));
                    }
                    field_read_revisions = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetEntryAclSetArg {
            entry_ref: field_entry_ref
                .ok_or_else(|| ::serde::de::Error::missing_field("entry_ref"))?,
            read_data: field_read_data.and_then(Option::flatten),
            push_data: field_push_data.and_then(Option::flatten),
            read_revisions: field_read_revisions.and_then(Option::flatten),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("entry_ref", &self.entry_ref)?;
        if let Some(val) = &self.read_data {
            s.serialize_field("read_data", val)?;
        }
        if let Some(val) = &self.push_data {
            s.serialize_field("push_data", val)?;
        }
        if let Some(val) = &self.read_revisions {
            s.serialize_field("read_revisions", val)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntryAclSetArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetEntryAclSetArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntryAclSetArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetEntryAclSetArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetEntryAclSetArg",
            ASSET_ENTRY_ACL_SET_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetEntryAclSetArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetEntryAclSetArg", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetEntryAclSetError {
    BadEntryRef,
    NoPermission,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntryAclSetError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetEntryAclSetError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntryAclSetError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_entry_ref" => AssetEntryAclSetError::BadEntryRef,
                    "no_permission" => AssetEntryAclSetError::NoPermission,
                    _ => AssetEntryAclSetError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["bad_entry_ref", "no_permission", "other"];
        deserializer.deserialize_struct("AssetEntryAclSetError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetEntryAclSetError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetEntryAclSetError::BadEntryRef => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryAclSetError", 1)?;
                s.serialize_field(".tag", "bad_entry_ref")?;
                s.end()
            }
            AssetEntryAclSetError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryAclSetError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetEntryAclSetError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetEntryAclSetError {}

impl ::std::fmt::Display for AssetEntryAclSetError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetEntryIterArg {
    pub prefix: Option<String>,
    /// The maximum number of entries to return at once. For internal reasons, fewer than `limit`
    /// may be returned.
    pub limit: u32,
}

impl Default for AssetEntryIterArg {
    fn default() -> Self {
        AssetEntryIterArg {
            prefix: None,
            limit: 100,
        }
    }
}

impl AssetEntryIterArg {
    pub fn with_prefix(mut self, value: String) -> Self {
        self.prefix = Some(value);
        self
    }

    pub fn with_limit(mut self, value: u32) -> Self {
        self.limit = value;
        self
    }
}

const ASSET_ENTRY_ITER_ARG_FIELDS: &[&str] = &["prefix", "limit"];
impl AssetEntryIterArg {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AssetEntryIterArg, V::Error> {
        let mut field_prefix = None;
        let mut field_limit = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "prefix" => {
                    if field_prefix.is_some() {
                        return Err(::serde::de::Error::duplicate_field("prefix"));
                    }
                    field_prefix = Some(map.next_value()?);
                }
                "limit" => {
                    if field_limit.is_some() {
                        return Err(::serde::de::Error::duplicate_field("limit"));
                    }
                    field_limit = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = AssetEntryIterArg {
            prefix: field_prefix.and_then(Option::flatten),
            limit: field_limit.unwrap_or(100),
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        if let Some(val) = &self.prefix {
            s.serialize_field("prefix", val)?;
        }
        if self.limit != 100 {
            s.serialize_field("limit", &self.limit)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntryIterArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetEntryIterArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntryIterArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetEntryIterArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetEntryIterArg",
            ASSET_ENTRY_ITER_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetEntryIterArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetEntryIterArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetEntryIterError {
    /// If a pool has never had an asset, this is returned since pools are created lazily.
    Empty,
    NoPermission,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntryIterError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetEntryIterError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntryIterError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "empty" => AssetEntryIterError::Empty,
                    "no_permission" => AssetEntryIterError::NoPermission,
                    _ => AssetEntryIterError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["empty", "no_permission", "other"];
        deserializer.deserialize_struct("AssetEntryIterError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetEntryIterError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetEntryIterError::Empty => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryIterError", 1)?;
                s.serialize_field(".tag", "empty")?;
                s.end()
            }
            AssetEntryIterError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryIterError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetEntryIterError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetEntryIterError {}

impl ::std::fmt::Display for AssetEntryIterError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            AssetEntryIterError::Empty => f.write_str("If a pool has never had an asset, this is returned since pools are created lazily."),
            _ => write!(f, "{:?}", *self),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetEntryIterNextArg {
    /// Use the cursor from [`AssetEntryIterResult::cursor`](AssetEntryIterResult).
    pub cursor: String,
    /// The maximum number of entries to return at once. For internal reasons, fewer than `limit`
    /// may be returned.
    pub limit: u32,
}

impl AssetEntryIterNextArg {
    pub fn new(cursor: String) -> Self {
        AssetEntryIterNextArg { cursor, limit: 100 }
    }

    pub fn with_limit(mut self, value: u32) -> Self {
        self.limit = value;
        self
    }
}

const ASSET_ENTRY_ITER_NEXT_ARG_FIELDS: &[&str] = &["cursor", "limit"];
impl AssetEntryIterNextArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetEntryIterNextArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetEntryIterNextArg>, V::Error> {
        let mut field_cursor = None;
        let mut field_limit = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(::serde::de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                "limit" => {
                    if field_limit.is_some() {
                        return Err(::serde::de::Error::duplicate_field("limit"));
                    }
                    field_limit = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetEntryIterNextArg {
            cursor: field_cursor.ok_or_else(|| ::serde::de::Error::missing_field("cursor"))?,
            limit: field_limit.unwrap_or(100),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("cursor", &self.cursor)?;
        if self.limit != 100 {
            s.serialize_field("limit", &self.limit)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntryIterNextArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetEntryIterNextArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntryIterNextArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetEntryIterNextArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetEntryIterNextArg",
            ASSET_ENTRY_ITER_NEXT_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetEntryIterNextArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetEntryIterNextArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetEntryIterNextError {
    BadCursor,
    NoPermission,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntryIterNextError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetEntryIterNextError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntryIterNextError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_cursor" => AssetEntryIterNextError::BadCursor,
                    "no_permission" => AssetEntryIterNextError::NoPermission,
                    _ => AssetEntryIterNextError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["bad_cursor", "no_permission", "other"];
        deserializer.deserialize_struct("AssetEntryIterNextError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetEntryIterNextError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetEntryIterNextError::BadCursor => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryIterNextError", 1)?;
                s.serialize_field(".tag", "bad_cursor")?;
                s.end()
            }
            AssetEntryIterNextError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryIterNextError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetEntryIterNextError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetEntryIterNextError {}

impl ::std::fmt::Display for AssetEntryIterNextError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetEntryIterResult {
    pub entries: Vec<AssetEntry>,
    pub cursor: String,
    pub has_more: bool,
    /// In lexicographic (byte-order) sorting.
    pub collapsed_prefixes: Vec<String>,
}

impl AssetEntryIterResult {
    pub fn new(
        entries: Vec<AssetEntry>,
        cursor: String,
        has_more: bool,
        collapsed_prefixes: Vec<String>,
    ) -> Self {
        AssetEntryIterResult {
            entries,
            cursor,
            has_more,
            collapsed_prefixes,
        }
    }
}

const ASSET_ENTRY_ITER_RESULT_FIELDS: &[&str] =
    &["entries", "cursor", "has_more", "collapsed_prefixes"];
impl AssetEntryIterResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetEntryIterResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetEntryIterResult>, V::Error> {
        let mut field_entries = None;
        let mut field_cursor = None;
        let mut field_has_more = None;
        let mut field_collapsed_prefixes = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "entries" => {
                    if field_entries.is_some() {
                        return Err(::serde::de::Error::duplicate_field("entries"));
                    }
                    field_entries = Some(map.next_value()?);
                }
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(::serde::de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                "has_more" => {
                    if field_has_more.is_some() {
                        return Err(::serde::de::Error::duplicate_field("has_more"));
                    }
                    field_has_more = Some(map.next_value()?);
                }
                "collapsed_prefixes" => {
                    if field_collapsed_prefixes.is_some() {
                        return Err(::serde::de::Error::duplicate_field("collapsed_prefixes"));
                    }
                    field_collapsed_prefixes = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetEntryIterResult {
            entries: field_entries.ok_or_else(|| ::serde::de::Error::missing_field("entries"))?,
            cursor: field_cursor.ok_or_else(|| ::serde::de::Error::missing_field("cursor"))?,
            has_more: field_has_more
                .ok_or_else(|| ::serde::de::Error::missing_field("has_more"))?,
            collapsed_prefixes: field_collapsed_prefixes
                .ok_or_else(|| ::serde::de::Error::missing_field("collapsed_prefixes"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("entries", &self.entries)?;
        s.serialize_field("cursor", &self.cursor)?;
        s.serialize_field("has_more", &self.has_more)?;
        s.serialize_field("collapsed_prefixes", &self.collapsed_prefixes)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntryIterResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetEntryIterResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntryIterResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetEntryIterResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetEntryIterResult",
            ASSET_ENTRY_ITER_RESULT_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetEntryIterResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetEntryIterResult", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetEntryListArg {
    pub prefix: Option<String>,
    /// The maximum number of entries to return at once. For internal reasons, fewer than `limit`
    /// may be returned.
    pub limit: u32,
    pub order: EntryListOrder,
}

impl Default for AssetEntryListArg {
    fn default() -> Self {
        AssetEntryListArg {
            prefix: None,
            limit: 100,
            order: EntryListOrder::Asc,
        }
    }
}

impl AssetEntryListArg {
    pub fn with_prefix(mut self, value: String) -> Self {
        self.prefix = Some(value);
        self
    }

    pub fn with_limit(mut self, value: u32) -> Self {
        self.limit = value;
        self
    }

    pub fn with_order(mut self, value: EntryListOrder) -> Self {
        self.order = value;
        self
    }
}

const ASSET_ENTRY_LIST_ARG_FIELDS: &[&str] = &["prefix", "limit", "order"];
impl AssetEntryListArg {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AssetEntryListArg, V::Error> {
        let mut field_prefix = None;
        let mut field_limit = None;
        let mut field_order = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "prefix" => {
                    if field_prefix.is_some() {
                        return Err(::serde::de::Error::duplicate_field("prefix"));
                    }
                    field_prefix = Some(map.next_value()?);
                }
                "limit" => {
                    if field_limit.is_some() {
                        return Err(::serde::de::Error::duplicate_field("limit"));
                    }
                    field_limit = Some(map.next_value()?);
                }
                "order" => {
                    if field_order.is_some() {
                        return Err(::serde::de::Error::duplicate_field("order"));
                    }
                    field_order = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = AssetEntryListArg {
            prefix: field_prefix.and_then(Option::flatten),
            limit: field_limit.unwrap_or(100),
            order: field_order.unwrap_or(EntryListOrder::Asc),
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        if let Some(val) = &self.prefix {
            s.serialize_field("prefix", val)?;
        }
        if self.limit != 100 {
            s.serialize_field("limit", &self.limit)?;
        }
        if self.order != EntryListOrder::Asc {
            s.serialize_field("order", &self.order)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntryListArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetEntryListArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntryListArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetEntryListArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetEntryListArg",
            ASSET_ENTRY_LIST_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetEntryListArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetEntryListArg", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetEntryListError {
    /// If a pool has never had an asset, this is returned since pools are created lazily.
    Empty,
    NoPermission,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntryListError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetEntryListError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntryListError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "empty" => AssetEntryListError::Empty,
                    "no_permission" => AssetEntryListError::NoPermission,
                    _ => AssetEntryListError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["empty", "no_permission", "other"];
        deserializer.deserialize_struct("AssetEntryListError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetEntryListError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetEntryListError::Empty => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryListError", 1)?;
                s.serialize_field(".tag", "empty")?;
                s.end()
            }
            AssetEntryListError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryListError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetEntryListError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetEntryListError {}

impl ::std::fmt::Display for AssetEntryListError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            AssetEntryListError::Empty => f.write_str("If a pool has never had an asset, this is returned since pools are created lazily."),
            _ => write!(f, "{:?}", *self),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetEntryListNextArg {
    /// Use the cursor from [`AssetEntryListResult::cursor`](AssetEntryListResult).
    pub cursor: String,
    /// The maximum number of entries to return at once. For internal reasons, fewer than `limit`
    /// may be returned.
    pub limit: u32,
}

impl AssetEntryListNextArg {
    pub fn new(cursor: String) -> Self {
        AssetEntryListNextArg { cursor, limit: 100 }
    }

    pub fn with_limit(mut self, value: u32) -> Self {
        self.limit = value;
        self
    }
}

const ASSET_ENTRY_LIST_NEXT_ARG_FIELDS: &[&str] = &["cursor", "limit"];
impl AssetEntryListNextArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetEntryListNextArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetEntryListNextArg>, V::Error> {
        let mut field_cursor = None;
        let mut field_limit = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(::serde::de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                "limit" => {
                    if field_limit.is_some() {
                        return Err(::serde::de::Error::duplicate_field("limit"));
                    }
                    field_limit = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetEntryListNextArg {
            cursor: field_cursor.ok_or_else(|| ::serde::de::Error::missing_field("cursor"))?,
            limit: field_limit.unwrap_or(100),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("cursor", &self.cursor)?;
        if self.limit != 100 {
            s.serialize_field("limit", &self.limit)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntryListNextArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetEntryListNextArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntryListNextArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetEntryListNextArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetEntryListNextArg",
            ASSET_ENTRY_LIST_NEXT_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetEntryListNextArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetEntryListNextArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetEntryListNextError {
    BadCursor,
    NoPermission,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntryListNextError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetEntryListNextError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntryListNextError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_cursor" => AssetEntryListNextError::BadCursor,
                    "no_permission" => AssetEntryListNextError::NoPermission,
                    _ => AssetEntryListNextError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["bad_cursor", "no_permission", "other"];
        deserializer.deserialize_struct("AssetEntryListNextError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetEntryListNextError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetEntryListNextError::BadCursor => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryListNextError", 1)?;
                s.serialize_field(".tag", "bad_cursor")?;
                s.end()
            }
            AssetEntryListNextError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryListNextError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetEntryListNextError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetEntryListNextError {}

impl ::std::fmt::Display for AssetEntryListNextError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetEntryListResult {
    pub entries: Vec<AssetEntry>,
    pub cursor: String,
    pub has_more: bool,
    /// In lexicographic (byte-order) sorting.
    pub collapsed_prefixes: Vec<String>,
}

impl AssetEntryListResult {
    pub fn new(
        entries: Vec<AssetEntry>,
        cursor: String,
        has_more: bool,
        collapsed_prefixes: Vec<String>,
    ) -> Self {
        AssetEntryListResult {
            entries,
            cursor,
            has_more,
            collapsed_prefixes,
        }
    }
}

const ASSET_ENTRY_LIST_RESULT_FIELDS: &[&str] =
    &["entries", "cursor", "has_more", "collapsed_prefixes"];
impl AssetEntryListResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetEntryListResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetEntryListResult>, V::Error> {
        let mut field_entries = None;
        let mut field_cursor = None;
        let mut field_has_more = None;
        let mut field_collapsed_prefixes = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "entries" => {
                    if field_entries.is_some() {
                        return Err(::serde::de::Error::duplicate_field("entries"));
                    }
                    field_entries = Some(map.next_value()?);
                }
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(::serde::de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                "has_more" => {
                    if field_has_more.is_some() {
                        return Err(::serde::de::Error::duplicate_field("has_more"));
                    }
                    field_has_more = Some(map.next_value()?);
                }
                "collapsed_prefixes" => {
                    if field_collapsed_prefixes.is_some() {
                        return Err(::serde::de::Error::duplicate_field("collapsed_prefixes"));
                    }
                    field_collapsed_prefixes = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetEntryListResult {
            entries: field_entries.ok_or_else(|| ::serde::de::Error::missing_field("entries"))?,
            cursor: field_cursor.ok_or_else(|| ::serde::de::Error::missing_field("cursor"))?,
            has_more: field_has_more
                .ok_or_else(|| ::serde::de::Error::missing_field("has_more"))?,
            collapsed_prefixes: field_collapsed_prefixes
                .ok_or_else(|| ::serde::de::Error::missing_field("collapsed_prefixes"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("entries", &self.entries)?;
        s.serialize_field("cursor", &self.cursor)?;
        s.serialize_field("has_more", &self.has_more)?;
        s.serialize_field("collapsed_prefixes", &self.collapsed_prefixes)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntryListResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetEntryListResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntryListResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetEntryListResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetEntryListResult",
            ASSET_ENTRY_LIST_RESULT_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetEntryListResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetEntryListResult", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetEntryOp {
    Add,
    /// Functionally the same as an add, but indicates it was forked from another asset chain due to
    /// conflict-policy.
    Fork,
    Edit,
    Push,
    Delete,
    /// Metadata for asset was added, modified, or removed.
    Metadata,
    Move,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntryOp {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetEntryOp;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntryOp structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "add" => AssetEntryOp::Add,
                    "fork" => AssetEntryOp::Fork,
                    "edit" => AssetEntryOp::Edit,
                    "push" => AssetEntryOp::Push,
                    "delete" => AssetEntryOp::Delete,
                    "metadata" => AssetEntryOp::Metadata,
                    "move" => AssetEntryOp::Move,
                    _ => AssetEntryOp::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &[
            "add", "fork", "edit", "push", "delete", "metadata", "move", "other",
        ];
        deserializer.deserialize_struct("AssetEntryOp", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetEntryOp {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetEntryOp::Add => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryOp", 1)?;
                s.serialize_field(".tag", "add")?;
                s.end()
            }
            AssetEntryOp::Fork => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryOp", 1)?;
                s.serialize_field(".tag", "fork")?;
                s.end()
            }
            AssetEntryOp::Edit => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryOp", 1)?;
                s.serialize_field(".tag", "edit")?;
                s.end()
            }
            AssetEntryOp::Push => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryOp", 1)?;
                s.serialize_field(".tag", "push")?;
                s.end()
            }
            AssetEntryOp::Delete => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryOp", 1)?;
                s.serialize_field(".tag", "delete")?;
                s.end()
            }
            AssetEntryOp::Metadata => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryOp", 1)?;
                s.serialize_field(".tag", "metadata")?;
                s.end()
            }
            AssetEntryOp::Move => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntryOp", 1)?;
                s.serialize_field(".tag", "move")?;
                s.end()
            }
            AssetEntryOp::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetEntrySearchArg {
    pub q: String,
    pub asset_pool_path: Option<String>,
}

impl AssetEntrySearchArg {
    pub fn new(q: String) -> Self {
        AssetEntrySearchArg {
            q,
            asset_pool_path: None,
        }
    }

    pub fn with_asset_pool_path(mut self, value: String) -> Self {
        self.asset_pool_path = Some(value);
        self
    }
}

const ASSET_ENTRY_SEARCH_ARG_FIELDS: &[&str] = &["q", "asset_pool_path"];
impl AssetEntrySearchArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetEntrySearchArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetEntrySearchArg>, V::Error> {
        let mut field_q = None;
        let mut field_asset_pool_path = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "q" => {
                    if field_q.is_some() {
                        return Err(::serde::de::Error::duplicate_field("q"));
                    }
                    field_q = Some(map.next_value()?);
                }
                "asset_pool_path" => {
                    if field_asset_pool_path.is_some() {
                        return Err(::serde::de::Error::duplicate_field("asset_pool_path"));
                    }
                    field_asset_pool_path = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetEntrySearchArg {
            q: field_q.ok_or_else(|| ::serde::de::Error::missing_field("q"))?,
            asset_pool_path: field_asset_pool_path.and_then(Option::flatten),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("q", &self.q)?;
        if let Some(val) = &self.asset_pool_path {
            s.serialize_field("asset_pool_path", val)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntrySearchArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetEntrySearchArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntrySearchArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetEntrySearchArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetEntrySearchArg",
            ASSET_ENTRY_SEARCH_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetEntrySearchArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetEntrySearchArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetEntrySearchError {
    BadAssetPoolPath,
    NoPermission,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntrySearchError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetEntrySearchError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntrySearchError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_asset_pool_path" => AssetEntrySearchError::BadAssetPoolPath,
                    "no_permission" => AssetEntrySearchError::NoPermission,
                    _ => AssetEntrySearchError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["bad_asset_pool_path", "no_permission", "other"];
        deserializer.deserialize_struct("AssetEntrySearchError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetEntrySearchError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetEntrySearchError::BadAssetPoolPath => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntrySearchError", 1)?;
                s.serialize_field(".tag", "bad_asset_pool_path")?;
                s.end()
            }
            AssetEntrySearchError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetEntrySearchError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetEntrySearchError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetEntrySearchError {}

impl ::std::fmt::Display for AssetEntrySearchError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetEntrySearchResult {
    pub semantic_matches: Vec<AssetEntry>,
}

impl AssetEntrySearchResult {
    pub fn new(semantic_matches: Vec<AssetEntry>) -> Self {
        AssetEntrySearchResult { semantic_matches }
    }
}

const ASSET_ENTRY_SEARCH_RESULT_FIELDS: &[&str] = &["semantic_matches"];
impl AssetEntrySearchResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetEntrySearchResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetEntrySearchResult>, V::Error> {
        let mut field_semantic_matches = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "semantic_matches" => {
                    if field_semantic_matches.is_some() {
                        return Err(::serde::de::Error::duplicate_field("semantic_matches"));
                    }
                    field_semantic_matches = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetEntrySearchResult {
            semantic_matches: field_semantic_matches
                .ok_or_else(|| ::serde::de::Error::missing_field("semantic_matches"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("semantic_matches", &self.semantic_matches)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetEntrySearchResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetEntrySearchResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetEntrySearchResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetEntrySearchResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetEntrySearchResult",
            ASSET_ENTRY_SEARCH_RESULT_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetEntrySearchResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetEntrySearchResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetGetArg {
    pub name: String,
}

impl AssetGetArg {
    pub fn new(name: String) -> Self {
        AssetGetArg { name }
    }
}

const ASSET_GET_ARG_FIELDS: &[&str] = &["name"];
impl AssetGetArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetGetArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetGetArg>, V::Error> {
        let mut field_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "name" => {
                    if field_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetGetArg {
            name: field_name.ok_or_else(|| ::serde::de::Error::missing_field("name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("name", &self.name)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetGetArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetGetArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetGetArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetGetArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AssetGetArg", ASSET_GET_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AssetGetArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetGetArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetGetError {
    BadName,
    NoPermission,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetGetError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetGetError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetGetError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_name" => AssetGetError::BadName,
                    "no_permission" => AssetGetError::NoPermission,
                    _ => AssetGetError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["bad_name", "no_permission", "other"];
        deserializer.deserialize_struct("AssetGetError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetGetError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetGetError::BadName => {
                // unit
                let mut s = serializer.serialize_struct("AssetGetError", 1)?;
                s.serialize_field(".tag", "bad_name")?;
                s.end()
            }
            AssetGetError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetGetError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetGetError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetGetError {}

impl ::std::fmt::Display for AssetGetError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetGetResult {
    pub entry: AssetEntry,
}

impl AssetGetResult {
    pub fn new(entry: AssetEntry) -> Self {
        AssetGetResult { entry }
    }
}

const ASSET_GET_RESULT_FIELDS: &[&str] = &["entry"];
impl AssetGetResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetGetResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetGetResult>, V::Error> {
        let mut field_entry = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "entry" => {
                    if field_entry.is_some() {
                        return Err(::serde::de::Error::duplicate_field("entry"));
                    }
                    field_entry = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetGetResult {
            entry: field_entry.ok_or_else(|| ::serde::de::Error::missing_field("entry"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("entry", &self.entry)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetGetResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetGetResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetGetResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetGetResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AssetGetResult", ASSET_GET_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AssetGetResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetGetResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetInfo {
    pub rev_id: String,
    pub created_by: AssetCreatedBy,
    /// Number of bytes. Deleted assets have a size of 0.
    pub size: u64,
    /// SHA-256 hash of the content. Unset if it's a deletion.
    pub hash: Option<String>,
    /// A url to the asset data that expires in 24 hours. Unset if it's a deletion.
    pub url: Option<String>,
}

impl AssetInfo {
    pub fn new(rev_id: String, created_by: AssetCreatedBy, size: u64) -> Self {
        AssetInfo {
            rev_id,
            created_by,
            size,
            hash: None,
            url: None,
        }
    }

    pub fn with_hash(mut self, value: String) -> Self {
        self.hash = Some(value);
        self
    }

    pub fn with_url(mut self, value: String) -> Self {
        self.url = Some(value);
        self
    }
}

const ASSET_INFO_FIELDS: &[&str] = &["rev_id", "created_by", "size", "hash", "url"];
impl AssetInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetInfo, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetInfo>, V::Error> {
        let mut field_rev_id = None;
        let mut field_created_by = None;
        let mut field_size = None;
        let mut field_hash = None;
        let mut field_url = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "rev_id" => {
                    if field_rev_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("rev_id"));
                    }
                    field_rev_id = Some(map.next_value()?);
                }
                "created_by" => {
                    if field_created_by.is_some() {
                        return Err(::serde::de::Error::duplicate_field("created_by"));
                    }
                    field_created_by = Some(map.next_value()?);
                }
                "size" => {
                    if field_size.is_some() {
                        return Err(::serde::de::Error::duplicate_field("size"));
                    }
                    field_size = Some(map.next_value()?);
                }
                "hash" => {
                    if field_hash.is_some() {
                        return Err(::serde::de::Error::duplicate_field("hash"));
                    }
                    field_hash = Some(map.next_value()?);
                }
                "url" => {
                    if field_url.is_some() {
                        return Err(::serde::de::Error::duplicate_field("url"));
                    }
                    field_url = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetInfo {
            rev_id: field_rev_id.ok_or_else(|| ::serde::de::Error::missing_field("rev_id"))?,
            created_by: field_created_by
                .ok_or_else(|| ::serde::de::Error::missing_field("created_by"))?,
            size: field_size.ok_or_else(|| ::serde::de::Error::missing_field("size"))?,
            hash: field_hash.and_then(Option::flatten),
            url: field_url.and_then(Option::flatten),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("rev_id", &self.rev_id)?;
        s.serialize_field("created_by", &self.created_by)?;
        s.serialize_field("size", &self.size)?;
        if let Some(val) = &self.hash {
            s.serialize_field("hash", val)?;
        }
        if let Some(val) = &self.url {
            s.serialize_field("url", val)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AssetInfo", ASSET_INFO_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AssetInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetInfo", 5)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetMetadataInfo {
    pub rev_id: String,
    pub created_by: AssetCreatedBy,
    /// Number of bytes. Deleted assets have a size of 0.
    pub size: u64,
    /// SHA-256 hash of the content. Unset if it's a deletion.
    pub hash: Option<String>,
    /// A url to the asset data that expires in 24 hours. Unset if it's a deletion.
    pub url: Option<String>,
    /// If the metadata specified a `title` key with string value, this is a reproduction of it
    /// truncated to 64-chars.
    pub title: Option<String>,
    /// If the metadata specified a `content_type` key with value having fewer than 64-chars, this
    /// is a reproduction of it.
    pub content_type: Option<String>,
    /// Set if the metadata specified an `encrypted` key.
    pub content_encrypted: Option<ContentEncryptedInfo>,
}

impl AssetMetadataInfo {
    pub fn new(rev_id: String, created_by: AssetCreatedBy, size: u64) -> Self {
        AssetMetadataInfo {
            rev_id,
            created_by,
            size,
            hash: None,
            url: None,
            title: None,
            content_type: None,
            content_encrypted: None,
        }
    }

    pub fn with_hash(mut self, value: String) -> Self {
        self.hash = Some(value);
        self
    }

    pub fn with_url(mut self, value: String) -> Self {
        self.url = Some(value);
        self
    }

    pub fn with_title(mut self, value: String) -> Self {
        self.title = Some(value);
        self
    }

    pub fn with_content_type(mut self, value: String) -> Self {
        self.content_type = Some(value);
        self
    }

    pub fn with_content_encrypted(mut self, value: ContentEncryptedInfo) -> Self {
        self.content_encrypted = Some(value);
        self
    }
}

const ASSET_METADATA_INFO_FIELDS: &[&str] = &[
    "rev_id",
    "created_by",
    "size",
    "hash",
    "url",
    "title",
    "content_type",
    "content_encrypted",
];
impl AssetMetadataInfo {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetMetadataInfo, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetMetadataInfo>, V::Error> {
        let mut field_rev_id = None;
        let mut field_created_by = None;
        let mut field_size = None;
        let mut field_hash = None;
        let mut field_url = None;
        let mut field_title = None;
        let mut field_content_type = None;
        let mut field_content_encrypted = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "rev_id" => {
                    if field_rev_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("rev_id"));
                    }
                    field_rev_id = Some(map.next_value()?);
                }
                "created_by" => {
                    if field_created_by.is_some() {
                        return Err(::serde::de::Error::duplicate_field("created_by"));
                    }
                    field_created_by = Some(map.next_value()?);
                }
                "size" => {
                    if field_size.is_some() {
                        return Err(::serde::de::Error::duplicate_field("size"));
                    }
                    field_size = Some(map.next_value()?);
                }
                "hash" => {
                    if field_hash.is_some() {
                        return Err(::serde::de::Error::duplicate_field("hash"));
                    }
                    field_hash = Some(map.next_value()?);
                }
                "url" => {
                    if field_url.is_some() {
                        return Err(::serde::de::Error::duplicate_field("url"));
                    }
                    field_url = Some(map.next_value()?);
                }
                "title" => {
                    if field_title.is_some() {
                        return Err(::serde::de::Error::duplicate_field("title"));
                    }
                    field_title = Some(map.next_value()?);
                }
                "content_type" => {
                    if field_content_type.is_some() {
                        return Err(::serde::de::Error::duplicate_field("content_type"));
                    }
                    field_content_type = Some(map.next_value()?);
                }
                "content_encrypted" => {
                    if field_content_encrypted.is_some() {
                        return Err(::serde::de::Error::duplicate_field("content_encrypted"));
                    }
                    field_content_encrypted = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetMetadataInfo {
            rev_id: field_rev_id.ok_or_else(|| ::serde::de::Error::missing_field("rev_id"))?,
            created_by: field_created_by
                .ok_or_else(|| ::serde::de::Error::missing_field("created_by"))?,
            size: field_size.ok_or_else(|| ::serde::de::Error::missing_field("size"))?,
            hash: field_hash.and_then(Option::flatten),
            url: field_url.and_then(Option::flatten),
            title: field_title.and_then(Option::flatten),
            content_type: field_content_type.and_then(Option::flatten),
            content_encrypted: field_content_encrypted.and_then(Option::flatten),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("rev_id", &self.rev_id)?;
        s.serialize_field("created_by", &self.created_by)?;
        s.serialize_field("size", &self.size)?;
        if let Some(val) = &self.hash {
            s.serialize_field("hash", val)?;
        }
        if let Some(val) = &self.url {
            s.serialize_field("url", val)?;
        }
        if let Some(val) = &self.title {
            s.serialize_field("title", val)?;
        }
        if let Some(val) = &self.content_type {
            s.serialize_field("content_type", val)?;
        }
        if let Some(val) = &self.content_encrypted {
            s.serialize_field("content_encrypted", val)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetMetadataInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetMetadataInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetMetadataInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetMetadataInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetMetadataInfo",
            ASSET_METADATA_INFO_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetMetadataInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetMetadataInfo", 8)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetMetadataPutArg {
    pub name: String,
    /// Must be JSON
    pub data: String,
    pub conflict_policy: PutConflictPolicy,
}

impl AssetMetadataPutArg {
    pub fn new(name: String, data: String) -> Self {
        AssetMetadataPutArg {
            name,
            data,
            conflict_policy: PutConflictPolicy::Override,
        }
    }

    pub fn with_conflict_policy(mut self, value: PutConflictPolicy) -> Self {
        self.conflict_policy = value;
        self
    }
}

const ASSET_METADATA_PUT_ARG_FIELDS: &[&str] = &["name", "data", "conflict_policy"];
impl AssetMetadataPutArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetMetadataPutArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetMetadataPutArg>, V::Error> {
        let mut field_name = None;
        let mut field_data = None;
        let mut field_conflict_policy = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "name" => {
                    if field_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "data" => {
                    if field_data.is_some() {
                        return Err(::serde::de::Error::duplicate_field("data"));
                    }
                    field_data = Some(map.next_value()?);
                }
                "conflict_policy" => {
                    if field_conflict_policy.is_some() {
                        return Err(::serde::de::Error::duplicate_field("conflict_policy"));
                    }
                    field_conflict_policy = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetMetadataPutArg {
            name: field_name.ok_or_else(|| ::serde::de::Error::missing_field("name"))?,
            data: field_data.ok_or_else(|| ::serde::de::Error::missing_field("data"))?,
            conflict_policy: field_conflict_policy.unwrap_or(PutConflictPolicy::Override),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("data", &self.data)?;
        if self.conflict_policy != PutConflictPolicy::Override {
            s.serialize_field("conflict_policy", &self.conflict_policy)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetMetadataPutArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetMetadataPutArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetMetadataPutArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetMetadataPutArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetMetadataPutArg",
            ASSET_METADATA_PUT_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetMetadataPutArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetMetadataPutArg", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetMetadataPutError {
    BadName,
    NoPermission,
    /// Only returned if conflict policy is set to reject.
    Conflict,
    OverQuota,
    /// Metadata must be valid JSON.
    BadMetadata,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetMetadataPutError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetMetadataPutError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetMetadataPutError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_name" => AssetMetadataPutError::BadName,
                    "no_permission" => AssetMetadataPutError::NoPermission,
                    "conflict" => AssetMetadataPutError::Conflict,
                    "over_quota" => AssetMetadataPutError::OverQuota,
                    "bad_metadata" => AssetMetadataPutError::BadMetadata,
                    _ => AssetMetadataPutError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &[
            "bad_name",
            "no_permission",
            "conflict",
            "over_quota",
            "bad_metadata",
            "other",
        ];
        deserializer.deserialize_struct("AssetMetadataPutError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetMetadataPutError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetMetadataPutError::BadName => {
                // unit
                let mut s = serializer.serialize_struct("AssetMetadataPutError", 1)?;
                s.serialize_field(".tag", "bad_name")?;
                s.end()
            }
            AssetMetadataPutError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetMetadataPutError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetMetadataPutError::Conflict => {
                // unit
                let mut s = serializer.serialize_struct("AssetMetadataPutError", 1)?;
                s.serialize_field(".tag", "conflict")?;
                s.end()
            }
            AssetMetadataPutError::OverQuota => {
                // unit
                let mut s = serializer.serialize_struct("AssetMetadataPutError", 1)?;
                s.serialize_field(".tag", "over_quota")?;
                s.end()
            }
            AssetMetadataPutError::BadMetadata => {
                // unit
                let mut s = serializer.serialize_struct("AssetMetadataPutError", 1)?;
                s.serialize_field(".tag", "bad_metadata")?;
                s.end()
            }
            AssetMetadataPutError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetMetadataPutError {}

impl ::std::fmt::Display for AssetMetadataPutError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            AssetMetadataPutError::Conflict => {
                f.write_str("Only returned if conflict policy is set to reject.")
            }
            AssetMetadataPutError::BadMetadata => f.write_str("Metadata must be valid JSON."),
            _ => write!(f, "{:?}", *self),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetMoveArg {
    pub source_name: String,
    pub target_name: String,
}

impl AssetMoveArg {
    pub fn new(source_name: String, target_name: String) -> Self {
        AssetMoveArg {
            source_name,
            target_name,
        }
    }
}

const ASSET_MOVE_ARG_FIELDS: &[&str] = &["source_name", "target_name"];
impl AssetMoveArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetMoveArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetMoveArg>, V::Error> {
        let mut field_source_name = None;
        let mut field_target_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "source_name" => {
                    if field_source_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("source_name"));
                    }
                    field_source_name = Some(map.next_value()?);
                }
                "target_name" => {
                    if field_target_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("target_name"));
                    }
                    field_target_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetMoveArg {
            source_name: field_source_name
                .ok_or_else(|| ::serde::de::Error::missing_field("source_name"))?,
            target_name: field_target_name
                .ok_or_else(|| ::serde::de::Error::missing_field("target_name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("source_name", &self.source_name)?;
        s.serialize_field("target_name", &self.target_name)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetMoveArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetMoveArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetMoveArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetMoveArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AssetMoveArg", ASSET_MOVE_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AssetMoveArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetMoveArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetMoveError {
    SourceBadName,
    NoPermission,
    TargetBadName,
    TargetNameConflict,
    /// Assets cannot be moved across asset pools.
    AssetPoolMismatch,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetMoveError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetMoveError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetMoveError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "source_bad_name" => AssetMoveError::SourceBadName,
                    "no_permission" => AssetMoveError::NoPermission,
                    "target_bad_name" => AssetMoveError::TargetBadName,
                    "target_name_conflict" => AssetMoveError::TargetNameConflict,
                    "asset_pool_mismatch" => AssetMoveError::AssetPoolMismatch,
                    _ => AssetMoveError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &[
            "source_bad_name",
            "no_permission",
            "target_bad_name",
            "target_name_conflict",
            "asset_pool_mismatch",
            "other",
        ];
        deserializer.deserialize_struct("AssetMoveError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetMoveError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetMoveError::SourceBadName => {
                // unit
                let mut s = serializer.serialize_struct("AssetMoveError", 1)?;
                s.serialize_field(".tag", "source_bad_name")?;
                s.end()
            }
            AssetMoveError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetMoveError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetMoveError::TargetBadName => {
                // unit
                let mut s = serializer.serialize_struct("AssetMoveError", 1)?;
                s.serialize_field(".tag", "target_bad_name")?;
                s.end()
            }
            AssetMoveError::TargetNameConflict => {
                // unit
                let mut s = serializer.serialize_struct("AssetMoveError", 1)?;
                s.serialize_field(".tag", "target_name_conflict")?;
                s.end()
            }
            AssetMoveError::AssetPoolMismatch => {
                // unit
                let mut s = serializer.serialize_struct("AssetMoveError", 1)?;
                s.serialize_field(".tag", "asset_pool_mismatch")?;
                s.end()
            }
            AssetMoveError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetMoveError {}

impl ::std::fmt::Display for AssetMoveError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            AssetMoveError::AssetPoolMismatch => {
                f.write_str("Assets cannot be moved across asset pools.")
            }
            _ => write!(f, "{:?}", *self),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetMoveResult {
    pub entry: AssetEntry,
}

impl AssetMoveResult {
    pub fn new(entry: AssetEntry) -> Self {
        AssetMoveResult { entry }
    }
}

const ASSET_MOVE_RESULT_FIELDS: &[&str] = &["entry"];
impl AssetMoveResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetMoveResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetMoveResult>, V::Error> {
        let mut field_entry = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "entry" => {
                    if field_entry.is_some() {
                        return Err(::serde::de::Error::duplicate_field("entry"));
                    }
                    field_entry = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetMoveResult {
            entry: field_entry.ok_or_else(|| ::serde::de::Error::missing_field("entry"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("entry", &self.entry)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetMoveResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetMoveResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetMoveResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetMoveResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AssetMoveResult", ASSET_MOVE_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AssetMoveResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetMoveResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetPoolFolderCollapseArg {
    pub prefix: String,
}

impl AssetPoolFolderCollapseArg {
    pub fn new(prefix: String) -> Self {
        AssetPoolFolderCollapseArg { prefix }
    }
}

const ASSET_POOL_FOLDER_COLLAPSE_ARG_FIELDS: &[&str] = &["prefix"];
impl AssetPoolFolderCollapseArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetPoolFolderCollapseArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetPoolFolderCollapseArg>, V::Error> {
        let mut field_prefix = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "prefix" => {
                    if field_prefix.is_some() {
                        return Err(::serde::de::Error::duplicate_field("prefix"));
                    }
                    field_prefix = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetPoolFolderCollapseArg {
            prefix: field_prefix.ok_or_else(|| ::serde::de::Error::missing_field("prefix"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("prefix", &self.prefix)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPoolFolderCollapseArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetPoolFolderCollapseArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPoolFolderCollapseArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetPoolFolderCollapseArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetPoolFolderCollapseArg",
            ASSET_POOL_FOLDER_COLLAPSE_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetPoolFolderCollapseArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetPoolFolderCollapseArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetPoolFolderCollapseError {
    NoPermission,
    BadFolder,
    CollapseLimitReached,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPoolFolderCollapseError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetPoolFolderCollapseError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPoolFolderCollapseError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "no_permission" => AssetPoolFolderCollapseError::NoPermission,
                    "bad_folder" => AssetPoolFolderCollapseError::BadFolder,
                    "collapse_limit_reached" => AssetPoolFolderCollapseError::CollapseLimitReached,
                    _ => AssetPoolFolderCollapseError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &[
            "no_permission",
            "bad_folder",
            "collapse_limit_reached",
            "other",
        ];
        deserializer.deserialize_struct("AssetPoolFolderCollapseError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetPoolFolderCollapseError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetPoolFolderCollapseError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetPoolFolderCollapseError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetPoolFolderCollapseError::BadFolder => {
                // unit
                let mut s = serializer.serialize_struct("AssetPoolFolderCollapseError", 1)?;
                s.serialize_field(".tag", "bad_folder")?;
                s.end()
            }
            AssetPoolFolderCollapseError::CollapseLimitReached => {
                // unit
                let mut s = serializer.serialize_struct("AssetPoolFolderCollapseError", 1)?;
                s.serialize_field(".tag", "collapse_limit_reached")?;
                s.end()
            }
            AssetPoolFolderCollapseError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetPoolFolderCollapseError {}

impl ::std::fmt::Display for AssetPoolFolderCollapseError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetPoolFolderExpandArg {
    pub prefix: String,
}

impl AssetPoolFolderExpandArg {
    pub fn new(prefix: String) -> Self {
        AssetPoolFolderExpandArg { prefix }
    }
}

const ASSET_POOL_FOLDER_EXPAND_ARG_FIELDS: &[&str] = &["prefix"];
impl AssetPoolFolderExpandArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetPoolFolderExpandArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetPoolFolderExpandArg>, V::Error> {
        let mut field_prefix = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "prefix" => {
                    if field_prefix.is_some() {
                        return Err(::serde::de::Error::duplicate_field("prefix"));
                    }
                    field_prefix = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetPoolFolderExpandArg {
            prefix: field_prefix.ok_or_else(|| ::serde::de::Error::missing_field("prefix"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("prefix", &self.prefix)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPoolFolderExpandArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetPoolFolderExpandArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPoolFolderExpandArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetPoolFolderExpandArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetPoolFolderExpandArg",
            ASSET_POOL_FOLDER_EXPAND_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetPoolFolderExpandArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetPoolFolderExpandArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetPoolFolderExpandError {
    NoPermission,
    BadFolder,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPoolFolderExpandError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetPoolFolderExpandError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPoolFolderExpandError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "no_permission" => AssetPoolFolderExpandError::NoPermission,
                    "bad_folder" => AssetPoolFolderExpandError::BadFolder,
                    _ => AssetPoolFolderExpandError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["no_permission", "bad_folder", "other"];
        deserializer.deserialize_struct("AssetPoolFolderExpandError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetPoolFolderExpandError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetPoolFolderExpandError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetPoolFolderExpandError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetPoolFolderExpandError::BadFolder => {
                // unit
                let mut s = serializer.serialize_struct("AssetPoolFolderExpandError", 1)?;
                s.serialize_field(".tag", "bad_folder")?;
                s.end()
            }
            AssetPoolFolderExpandError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetPoolFolderExpandError {}

impl ::std::fmt::Display for AssetPoolFolderExpandError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Default)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetPoolFolderListArg {
    pub prefix: Option<String>,
}

impl AssetPoolFolderListArg {
    pub fn with_prefix(mut self, value: String) -> Self {
        self.prefix = Some(value);
        self
    }
}

const ASSET_POOL_FOLDER_LIST_ARG_FIELDS: &[&str] = &["prefix"];
impl AssetPoolFolderListArg {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AssetPoolFolderListArg, V::Error> {
        let mut field_prefix = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "prefix" => {
                    if field_prefix.is_some() {
                        return Err(::serde::de::Error::duplicate_field("prefix"));
                    }
                    field_prefix = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = AssetPoolFolderListArg {
            prefix: field_prefix.and_then(Option::flatten),
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        if let Some(val) = &self.prefix {
            s.serialize_field("prefix", val)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPoolFolderListArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetPoolFolderListArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPoolFolderListArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetPoolFolderListArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetPoolFolderListArg",
            ASSET_POOL_FOLDER_LIST_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetPoolFolderListArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetPoolFolderListArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetPoolFolderListError {
    BadPrefix,
    NoPermission,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPoolFolderListError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetPoolFolderListError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPoolFolderListError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_prefix" => AssetPoolFolderListError::BadPrefix,
                    "no_permission" => AssetPoolFolderListError::NoPermission,
                    _ => AssetPoolFolderListError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["bad_prefix", "no_permission", "other"];
        deserializer.deserialize_struct("AssetPoolFolderListError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetPoolFolderListError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetPoolFolderListError::BadPrefix => {
                // unit
                let mut s = serializer.serialize_struct("AssetPoolFolderListError", 1)?;
                s.serialize_field(".tag", "bad_prefix")?;
                s.end()
            }
            AssetPoolFolderListError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetPoolFolderListError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetPoolFolderListError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetPoolFolderListError {}

impl ::std::fmt::Display for AssetPoolFolderListError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetPoolFolderListResult {
    pub folders: Vec<String>,
}

impl AssetPoolFolderListResult {
    pub fn new(folders: Vec<String>) -> Self {
        AssetPoolFolderListResult { folders }
    }
}

const ASSET_POOL_FOLDER_LIST_RESULT_FIELDS: &[&str] = &["folders"];
impl AssetPoolFolderListResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetPoolFolderListResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetPoolFolderListResult>, V::Error> {
        let mut field_folders = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "folders" => {
                    if field_folders.is_some() {
                        return Err(::serde::de::Error::duplicate_field("folders"));
                    }
                    field_folders = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetPoolFolderListResult {
            folders: field_folders.ok_or_else(|| ::serde::de::Error::missing_field("folders"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("folders", &self.folders)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPoolFolderListResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetPoolFolderListResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPoolFolderListResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetPoolFolderListResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetPoolFolderListResult",
            ASSET_POOL_FOLDER_LIST_RESULT_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetPoolFolderListResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetPoolFolderListResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetPoolQuotaGetArg {
    pub mount_point: String,
}

impl AssetPoolQuotaGetArg {
    pub fn new(mount_point: String) -> Self {
        AssetPoolQuotaGetArg { mount_point }
    }
}

const ASSET_POOL_QUOTA_GET_ARG_FIELDS: &[&str] = &["mount_point"];
impl AssetPoolQuotaGetArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetPoolQuotaGetArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetPoolQuotaGetArg>, V::Error> {
        let mut field_mount_point = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "mount_point" => {
                    if field_mount_point.is_some() {
                        return Err(::serde::de::Error::duplicate_field("mount_point"));
                    }
                    field_mount_point = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetPoolQuotaGetArg {
            mount_point: field_mount_point
                .ok_or_else(|| ::serde::de::Error::missing_field("mount_point"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("mount_point", &self.mount_point)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPoolQuotaGetArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetPoolQuotaGetArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPoolQuotaGetArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetPoolQuotaGetArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetPoolQuotaGetArg",
            ASSET_POOL_QUOTA_GET_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetPoolQuotaGetArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetPoolQuotaGetArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetPoolQuotaGetError {
    BadMountPoint,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPoolQuotaGetError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetPoolQuotaGetError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPoolQuotaGetError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_mount_point" => AssetPoolQuotaGetError::BadMountPoint,
                    _ => AssetPoolQuotaGetError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["bad_mount_point", "other"];
        deserializer.deserialize_struct("AssetPoolQuotaGetError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetPoolQuotaGetError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetPoolQuotaGetError::BadMountPoint => {
                // unit
                let mut s = serializer.serialize_struct("AssetPoolQuotaGetError", 1)?;
                s.serialize_field(".tag", "bad_mount_point")?;
                s.end()
            }
            AssetPoolQuotaGetError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetPoolQuotaGetError {}

impl ::std::fmt::Display for AssetPoolQuotaGetError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetPoolQuotaGetResult {
    pub active_count: u64,
    pub active_size: u64,
    pub total_count: u64,
    pub total_size: u64,
}

impl AssetPoolQuotaGetResult {
    pub fn new(active_count: u64, active_size: u64, total_count: u64, total_size: u64) -> Self {
        AssetPoolQuotaGetResult {
            active_count,
            active_size,
            total_count,
            total_size,
        }
    }
}

const ASSET_POOL_QUOTA_GET_RESULT_FIELDS: &[&str] =
    &["active_count", "active_size", "total_count", "total_size"];
impl AssetPoolQuotaGetResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetPoolQuotaGetResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetPoolQuotaGetResult>, V::Error> {
        let mut field_active_count = None;
        let mut field_active_size = None;
        let mut field_total_count = None;
        let mut field_total_size = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "active_count" => {
                    if field_active_count.is_some() {
                        return Err(::serde::de::Error::duplicate_field("active_count"));
                    }
                    field_active_count = Some(map.next_value()?);
                }
                "active_size" => {
                    if field_active_size.is_some() {
                        return Err(::serde::de::Error::duplicate_field("active_size"));
                    }
                    field_active_size = Some(map.next_value()?);
                }
                "total_count" => {
                    if field_total_count.is_some() {
                        return Err(::serde::de::Error::duplicate_field("total_count"));
                    }
                    field_total_count = Some(map.next_value()?);
                }
                "total_size" => {
                    if field_total_size.is_some() {
                        return Err(::serde::de::Error::duplicate_field("total_size"));
                    }
                    field_total_size = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetPoolQuotaGetResult {
            active_count: field_active_count
                .ok_or_else(|| ::serde::de::Error::missing_field("active_count"))?,
            active_size: field_active_size
                .ok_or_else(|| ::serde::de::Error::missing_field("active_size"))?,
            total_count: field_total_count
                .ok_or_else(|| ::serde::de::Error::missing_field("total_count"))?,
            total_size: field_total_size
                .ok_or_else(|| ::serde::de::Error::missing_field("total_size"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("active_count", &self.active_count)?;
        s.serialize_field("active_size", &self.active_size)?;
        s.serialize_field("total_count", &self.total_count)?;
        s.serialize_field("total_size", &self.total_size)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPoolQuotaGetResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetPoolQuotaGetResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPoolQuotaGetResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetPoolQuotaGetResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetPoolQuotaGetResult",
            ASSET_POOL_QUOTA_GET_RESULT_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetPoolQuotaGetResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetPoolQuotaGetResult", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetPushArg {
    pub name: String,
    pub data: Vec<u8>,
}

impl AssetPushArg {
    pub fn new(name: String, data: Vec<u8>) -> Self {
        AssetPushArg { name, data }
    }
}

const ASSET_PUSH_ARG_FIELDS: &[&str] = &["name", "data"];
impl AssetPushArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetPushArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetPushArg>, V::Error> {
        let mut field_name = None;
        let mut field_data = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "name" => {
                    if field_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "data" => {
                    if field_data.is_some() {
                        return Err(::serde::de::Error::duplicate_field("data"));
                    }
                    field_data = Some(
                        BASE64
                            .decode(map.next_value::<String>()?.as_bytes())
                            .map_err(::serde::de::Error::custom)?,
                    );
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetPushArg {
            name: field_name.ok_or_else(|| ::serde::de::Error::missing_field("name"))?,
            data: field_data.ok_or_else(|| ::serde::de::Error::missing_field("data"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("data", &BASE64.encode(&self.data))?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPushArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetPushArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPushArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetPushArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AssetPushArg", ASSET_PUSH_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AssetPushArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetPushArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetPushError {
    BadName,
    NoPermission,
    OverQuota,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPushError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetPushError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPushError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_name" => AssetPushError::BadName,
                    "no_permission" => AssetPushError::NoPermission,
                    "over_quota" => AssetPushError::OverQuota,
                    _ => AssetPushError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["bad_name", "no_permission", "over_quota", "other"];
        deserializer.deserialize_struct("AssetPushError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetPushError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetPushError::BadName => {
                // unit
                let mut s = serializer.serialize_struct("AssetPushError", 1)?;
                s.serialize_field(".tag", "bad_name")?;
                s.end()
            }
            AssetPushError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetPushError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetPushError::OverQuota => {
                // unit
                let mut s = serializer.serialize_struct("AssetPushError", 1)?;
                s.serialize_field(".tag", "over_quota")?;
                s.end()
            }
            AssetPushError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetPushError {}

impl ::std::fmt::Display for AssetPushError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetPushResult {
    pub entry: AssetEntry,
}

impl AssetPushResult {
    pub fn new(entry: AssetEntry) -> Self {
        AssetPushResult { entry }
    }
}

const ASSET_PUSH_RESULT_FIELDS: &[&str] = &["entry"];
impl AssetPushResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetPushResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetPushResult>, V::Error> {
        let mut field_entry = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "entry" => {
                    if field_entry.is_some() {
                        return Err(::serde::de::Error::duplicate_field("entry"));
                    }
                    field_entry = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetPushResult {
            entry: field_entry.ok_or_else(|| ::serde::de::Error::missing_field("entry"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("entry", &self.entry)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPushResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetPushResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPushResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetPushResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AssetPushResult", ASSET_PUSH_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AssetPushResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetPushResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetPushTextArg {
    pub name: String,
    pub data: String,
}

impl AssetPushTextArg {
    pub fn new(name: String, data: String) -> Self {
        AssetPushTextArg { name, data }
    }
}

const ASSET_PUSH_TEXT_ARG_FIELDS: &[&str] = &["name", "data"];
impl AssetPushTextArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetPushTextArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetPushTextArg>, V::Error> {
        let mut field_name = None;
        let mut field_data = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "name" => {
                    if field_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "data" => {
                    if field_data.is_some() {
                        return Err(::serde::de::Error::duplicate_field("data"));
                    }
                    field_data = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetPushTextArg {
            name: field_name.ok_or_else(|| ::serde::de::Error::missing_field("name"))?,
            data: field_data.ok_or_else(|| ::serde::de::Error::missing_field("data"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("data", &self.data)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPushTextArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetPushTextArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPushTextArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetPushTextArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetPushTextArg",
            ASSET_PUSH_TEXT_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetPushTextArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetPushTextArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetPutArg {
    pub name: String,
    pub data: Vec<u8>,
    pub conflict_policy: PutConflictPolicy,
}

impl AssetPutArg {
    pub fn new(name: String, data: Vec<u8>) -> Self {
        AssetPutArg {
            name,
            data,
            conflict_policy: PutConflictPolicy::Override,
        }
    }

    pub fn with_conflict_policy(mut self, value: PutConflictPolicy) -> Self {
        self.conflict_policy = value;
        self
    }
}

const ASSET_PUT_ARG_FIELDS: &[&str] = &["name", "data", "conflict_policy"];
impl AssetPutArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetPutArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetPutArg>, V::Error> {
        let mut field_name = None;
        let mut field_data = None;
        let mut field_conflict_policy = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "name" => {
                    if field_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "data" => {
                    if field_data.is_some() {
                        return Err(::serde::de::Error::duplicate_field("data"));
                    }
                    field_data = Some(
                        BASE64
                            .decode(map.next_value::<String>()?.as_bytes())
                            .map_err(::serde::de::Error::custom)?,
                    );
                }
                "conflict_policy" => {
                    if field_conflict_policy.is_some() {
                        return Err(::serde::de::Error::duplicate_field("conflict_policy"));
                    }
                    field_conflict_policy = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetPutArg {
            name: field_name.ok_or_else(|| ::serde::de::Error::missing_field("name"))?,
            data: field_data.ok_or_else(|| ::serde::de::Error::missing_field("data"))?,
            conflict_policy: field_conflict_policy.unwrap_or(PutConflictPolicy::Override),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("data", &BASE64.encode(&self.data))?;
        if self.conflict_policy != PutConflictPolicy::Override {
            s.serialize_field("conflict_policy", &self.conflict_policy)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPutArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetPutArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPutArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetPutArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AssetPutArg", ASSET_PUT_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AssetPutArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetPutArg", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetPutError {
    BadName,
    NoPermission,
    /// Only returned if conflict policy is set to reject.
    NameConflict,
    OverQuota,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPutError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetPutError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPutError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_name" => AssetPutError::BadName,
                    "no_permission" => AssetPutError::NoPermission,
                    "name_conflict" => AssetPutError::NameConflict,
                    "over_quota" => AssetPutError::OverQuota,
                    _ => AssetPutError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &[
            "bad_name",
            "no_permission",
            "name_conflict",
            "over_quota",
            "other",
        ];
        deserializer.deserialize_struct("AssetPutError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetPutError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetPutError::BadName => {
                // unit
                let mut s = serializer.serialize_struct("AssetPutError", 1)?;
                s.serialize_field(".tag", "bad_name")?;
                s.end()
            }
            AssetPutError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetPutError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetPutError::NameConflict => {
                // unit
                let mut s = serializer.serialize_struct("AssetPutError", 1)?;
                s.serialize_field(".tag", "name_conflict")?;
                s.end()
            }
            AssetPutError::OverQuota => {
                // unit
                let mut s = serializer.serialize_struct("AssetPutError", 1)?;
                s.serialize_field(".tag", "over_quota")?;
                s.end()
            }
            AssetPutError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetPutError {}

impl ::std::fmt::Display for AssetPutError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            AssetPutError::NameConflict => {
                f.write_str("Only returned if conflict policy is set to reject.")
            }
            _ => write!(f, "{:?}", *self),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetPutResult {
    pub entry: AssetEntry,
}

impl AssetPutResult {
    pub fn new(entry: AssetEntry) -> Self {
        AssetPutResult { entry }
    }
}

const ASSET_PUT_RESULT_FIELDS: &[&str] = &["entry"];
impl AssetPutResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetPutResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetPutResult>, V::Error> {
        let mut field_entry = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "entry" => {
                    if field_entry.is_some() {
                        return Err(::serde::de::Error::duplicate_field("entry"));
                    }
                    field_entry = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetPutResult {
            entry: field_entry.ok_or_else(|| ::serde::de::Error::missing_field("entry"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("entry", &self.entry)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPutResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetPutResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPutResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetPutResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AssetPutResult", ASSET_PUT_RESULT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AssetPutResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetPutResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetPutTextArg {
    pub name: String,
    pub data: String,
    pub conflict_policy: PutConflictPolicy,
}

impl AssetPutTextArg {
    pub fn new(name: String, data: String) -> Self {
        AssetPutTextArg {
            name,
            data,
            conflict_policy: PutConflictPolicy::Override,
        }
    }

    pub fn with_conflict_policy(mut self, value: PutConflictPolicy) -> Self {
        self.conflict_policy = value;
        self
    }
}

const ASSET_PUT_TEXT_ARG_FIELDS: &[&str] = &["name", "data", "conflict_policy"];
impl AssetPutTextArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetPutTextArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetPutTextArg>, V::Error> {
        let mut field_name = None;
        let mut field_data = None;
        let mut field_conflict_policy = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "name" => {
                    if field_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "data" => {
                    if field_data.is_some() {
                        return Err(::serde::de::Error::duplicate_field("data"));
                    }
                    field_data = Some(map.next_value()?);
                }
                "conflict_policy" => {
                    if field_conflict_policy.is_some() {
                        return Err(::serde::de::Error::duplicate_field("conflict_policy"));
                    }
                    field_conflict_policy = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetPutTextArg {
            name: field_name.ok_or_else(|| ::serde::de::Error::missing_field("name"))?,
            data: field_data.ok_or_else(|| ::serde::de::Error::missing_field("data"))?,
            conflict_policy: field_conflict_policy.unwrap_or(PutConflictPolicy::Override),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("name", &self.name)?;
        s.serialize_field("data", &self.data)?;
        if self.conflict_policy != PutConflictPolicy::Override {
            s.serialize_field("conflict_policy", &self.conflict_policy)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetPutTextArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetPutTextArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetPutTextArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetPutTextArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AssetPutTextArg", ASSET_PUT_TEXT_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AssetPutTextArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetPutTextArg", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetRemoveArg {
    pub name: String,
}

impl AssetRemoveArg {
    pub fn new(name: String) -> Self {
        AssetRemoveArg { name }
    }
}

const ASSET_REMOVE_ARG_FIELDS: &[&str] = &["name"];
impl AssetRemoveArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetRemoveArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetRemoveArg>, V::Error> {
        let mut field_name = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "name" => {
                    if field_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetRemoveArg {
            name: field_name.ok_or_else(|| ::serde::de::Error::missing_field("name"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("name", &self.name)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetRemoveArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetRemoveArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetRemoveArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetRemoveArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AssetRemoveArg", ASSET_REMOVE_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AssetRemoveArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetRemoveArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetRemoveError {
    BadName,
    NoPermission,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetRemoveError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetRemoveError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetRemoveError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_name" => AssetRemoveError::BadName,
                    "no_permission" => AssetRemoveError::NoPermission,
                    _ => AssetRemoveError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["bad_name", "no_permission", "other"];
        deserializer.deserialize_struct("AssetRemoveError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetRemoveError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetRemoveError::BadName => {
                // unit
                let mut s = serializer.serialize_struct("AssetRemoveError", 1)?;
                s.serialize_field(".tag", "bad_name")?;
                s.end()
            }
            AssetRemoveError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetRemoveError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetRemoveError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetRemoveError {}

impl ::std::fmt::Display for AssetRemoveError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetRemoveResult {
    pub entry: AssetEntry,
}

impl AssetRemoveResult {
    pub fn new(entry: AssetEntry) -> Self {
        AssetRemoveResult { entry }
    }
}

const ASSET_REMOVE_RESULT_FIELDS: &[&str] = &["entry"];
impl AssetRemoveResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetRemoveResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetRemoveResult>, V::Error> {
        let mut field_entry = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "entry" => {
                    if field_entry.is_some() {
                        return Err(::serde::de::Error::duplicate_field("entry"));
                    }
                    field_entry = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetRemoveResult {
            entry: field_entry.ok_or_else(|| ::serde::de::Error::missing_field("entry"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("entry", &self.entry)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetRemoveResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetRemoveResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetRemoveResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetRemoveResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetRemoveResult",
            ASSET_REMOVE_RESULT_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetRemoveResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetRemoveResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetReplaceArg {
    pub entry_id: String,
    pub data: Vec<u8>,
    pub rev_id: Option<String>,
    pub conflict_policy: ReplaceConflictPolicy,
}

impl AssetReplaceArg {
    pub fn new(entry_id: String, data: Vec<u8>) -> Self {
        AssetReplaceArg {
            entry_id,
            data,
            rev_id: None,
            conflict_policy: ReplaceConflictPolicy::Reject,
        }
    }

    pub fn with_rev_id(mut self, value: String) -> Self {
        self.rev_id = Some(value);
        self
    }

    pub fn with_conflict_policy(mut self, value: ReplaceConflictPolicy) -> Self {
        self.conflict_policy = value;
        self
    }
}

const ASSET_REPLACE_ARG_FIELDS: &[&str] = &["entry_id", "data", "rev_id", "conflict_policy"];
impl AssetReplaceArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetReplaceArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetReplaceArg>, V::Error> {
        let mut field_entry_id = None;
        let mut field_data = None;
        let mut field_rev_id = None;
        let mut field_conflict_policy = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "entry_id" => {
                    if field_entry_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("entry_id"));
                    }
                    field_entry_id = Some(map.next_value()?);
                }
                "data" => {
                    if field_data.is_some() {
                        return Err(::serde::de::Error::duplicate_field("data"));
                    }
                    field_data = Some(
                        BASE64
                            .decode(map.next_value::<String>()?.as_bytes())
                            .map_err(::serde::de::Error::custom)?,
                    );
                }
                "rev_id" => {
                    if field_rev_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("rev_id"));
                    }
                    field_rev_id = Some(map.next_value()?);
                }
                "conflict_policy" => {
                    if field_conflict_policy.is_some() {
                        return Err(::serde::de::Error::duplicate_field("conflict_policy"));
                    }
                    field_conflict_policy = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetReplaceArg {
            entry_id: field_entry_id
                .ok_or_else(|| ::serde::de::Error::missing_field("entry_id"))?,
            data: field_data.ok_or_else(|| ::serde::de::Error::missing_field("data"))?,
            rev_id: field_rev_id.and_then(Option::flatten),
            conflict_policy: field_conflict_policy.unwrap_or(ReplaceConflictPolicy::Reject),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("entry_id", &self.entry_id)?;
        s.serialize_field("data", &BASE64.encode(&self.data))?;
        if let Some(val) = &self.rev_id {
            s.serialize_field("rev_id", val)?;
        }
        if self.conflict_policy != ReplaceConflictPolicy::Reject {
            s.serialize_field("conflict_policy", &self.conflict_policy)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetReplaceArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetReplaceArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetReplaceArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetReplaceArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AssetReplaceArg", ASSET_REPLACE_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AssetReplaceArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetReplaceArg", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetReplaceError {
    BadEntryId,
    NoPermission,
    BadRevId,
    /// Revision ID is no longer the most recent for the asset.
    OldRevId,
    OverQuota,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetReplaceError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetReplaceError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetReplaceError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_entry_id" => AssetReplaceError::BadEntryId,
                    "no_permission" => AssetReplaceError::NoPermission,
                    "bad_rev_id" => AssetReplaceError::BadRevId,
                    "old_rev_id" => AssetReplaceError::OldRevId,
                    "over_quota" => AssetReplaceError::OverQuota,
                    _ => AssetReplaceError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &[
            "bad_entry_id",
            "no_permission",
            "bad_rev_id",
            "old_rev_id",
            "over_quota",
            "other",
        ];
        deserializer.deserialize_struct("AssetReplaceError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetReplaceError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetReplaceError::BadEntryId => {
                // unit
                let mut s = serializer.serialize_struct("AssetReplaceError", 1)?;
                s.serialize_field(".tag", "bad_entry_id")?;
                s.end()
            }
            AssetReplaceError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetReplaceError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetReplaceError::BadRevId => {
                // unit
                let mut s = serializer.serialize_struct("AssetReplaceError", 1)?;
                s.serialize_field(".tag", "bad_rev_id")?;
                s.end()
            }
            AssetReplaceError::OldRevId => {
                // unit
                let mut s = serializer.serialize_struct("AssetReplaceError", 1)?;
                s.serialize_field(".tag", "old_rev_id")?;
                s.end()
            }
            AssetReplaceError::OverQuota => {
                // unit
                let mut s = serializer.serialize_struct("AssetReplaceError", 1)?;
                s.serialize_field(".tag", "over_quota")?;
                s.end()
            }
            AssetReplaceError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetReplaceError {}

impl ::std::fmt::Display for AssetReplaceError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            AssetReplaceError::OldRevId => {
                f.write_str("Revision ID is no longer the most recent for the asset.")
            }
            _ => write!(f, "{:?}", *self),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetReplaceResult {
    pub entry: AssetEntry,
}

impl AssetReplaceResult {
    pub fn new(entry: AssetEntry) -> Self {
        AssetReplaceResult { entry }
    }
}

const ASSET_REPLACE_RESULT_FIELDS: &[&str] = &["entry"];
impl AssetReplaceResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetReplaceResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetReplaceResult>, V::Error> {
        let mut field_entry = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "entry" => {
                    if field_entry.is_some() {
                        return Err(::serde::de::Error::duplicate_field("entry"));
                    }
                    field_entry = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetReplaceResult {
            entry: field_entry.ok_or_else(|| ::serde::de::Error::missing_field("entry"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("entry", &self.entry)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetReplaceResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetReplaceResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetReplaceResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetReplaceResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetReplaceResult",
            ASSET_REPLACE_RESULT_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetReplaceResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetReplaceResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetReplaceTextArg {
    pub entry_id: String,
    pub data: String,
    pub rev_id: Option<String>,
    pub conflict_policy: ReplaceConflictPolicy,
}

impl AssetReplaceTextArg {
    pub fn new(entry_id: String, data: String) -> Self {
        AssetReplaceTextArg {
            entry_id,
            data,
            rev_id: None,
            conflict_policy: ReplaceConflictPolicy::Reject,
        }
    }

    pub fn with_rev_id(mut self, value: String) -> Self {
        self.rev_id = Some(value);
        self
    }

    pub fn with_conflict_policy(mut self, value: ReplaceConflictPolicy) -> Self {
        self.conflict_policy = value;
        self
    }
}

const ASSET_REPLACE_TEXT_ARG_FIELDS: &[&str] = &["entry_id", "data", "rev_id", "conflict_policy"];
impl AssetReplaceTextArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetReplaceTextArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetReplaceTextArg>, V::Error> {
        let mut field_entry_id = None;
        let mut field_data = None;
        let mut field_rev_id = None;
        let mut field_conflict_policy = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "entry_id" => {
                    if field_entry_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("entry_id"));
                    }
                    field_entry_id = Some(map.next_value()?);
                }
                "data" => {
                    if field_data.is_some() {
                        return Err(::serde::de::Error::duplicate_field("data"));
                    }
                    field_data = Some(map.next_value()?);
                }
                "rev_id" => {
                    if field_rev_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("rev_id"));
                    }
                    field_rev_id = Some(map.next_value()?);
                }
                "conflict_policy" => {
                    if field_conflict_policy.is_some() {
                        return Err(::serde::de::Error::duplicate_field("conflict_policy"));
                    }
                    field_conflict_policy = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetReplaceTextArg {
            entry_id: field_entry_id
                .ok_or_else(|| ::serde::de::Error::missing_field("entry_id"))?,
            data: field_data.ok_or_else(|| ::serde::de::Error::missing_field("data"))?,
            rev_id: field_rev_id.and_then(Option::flatten),
            conflict_policy: field_conflict_policy.unwrap_or(ReplaceConflictPolicy::Reject),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("entry_id", &self.entry_id)?;
        s.serialize_field("data", &self.data)?;
        if let Some(val) = &self.rev_id {
            s.serialize_field("rev_id", val)?;
        }
        if self.conflict_policy != ReplaceConflictPolicy::Reject {
            s.serialize_field("conflict_policy", &self.conflict_policy)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetReplaceTextArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetReplaceTextArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetReplaceTextArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetReplaceTextArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetReplaceTextArg",
            ASSET_REPLACE_TEXT_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetReplaceTextArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetReplaceTextArg", 4)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetRevision {
    pub op: AssetEntryOp,
    pub asset: AssetInfo,
    pub metadata: Option<AssetMetadataInfo>,
}

impl AssetRevision {
    pub fn new(op: AssetEntryOp, asset: AssetInfo) -> Self {
        AssetRevision {
            op,
            asset,
            metadata: None,
        }
    }

    pub fn with_metadata(mut self, value: AssetMetadataInfo) -> Self {
        self.metadata = Some(value);
        self
    }
}

const ASSET_REVISION_FIELDS: &[&str] = &["op", "asset", "metadata"];
impl AssetRevision {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetRevision, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetRevision>, V::Error> {
        let mut field_op = None;
        let mut field_asset = None;
        let mut field_metadata = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "op" => {
                    if field_op.is_some() {
                        return Err(::serde::de::Error::duplicate_field("op"));
                    }
                    field_op = Some(map.next_value()?);
                }
                "asset" => {
                    if field_asset.is_some() {
                        return Err(::serde::de::Error::duplicate_field("asset"));
                    }
                    field_asset = Some(map.next_value()?);
                }
                "metadata" => {
                    if field_metadata.is_some() {
                        return Err(::serde::de::Error::duplicate_field("metadata"));
                    }
                    field_metadata = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetRevision {
            op: field_op.ok_or_else(|| ::serde::de::Error::missing_field("op"))?,
            asset: field_asset.ok_or_else(|| ::serde::de::Error::missing_field("asset"))?,
            metadata: field_metadata.and_then(Option::flatten),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("op", &self.op)?;
        s.serialize_field("asset", &self.asset)?;
        if let Some(val) = &self.metadata {
            s.serialize_field("metadata", val)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetRevision {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetRevision;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetRevision struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetRevision::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AssetRevision", ASSET_REVISION_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AssetRevision {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetRevision", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetRevisionCursor {
    pub cursor: String,
    /// If set, the next call will jump to the parent revision-chain that forked into the one that's
    /// been iterating.
    pub is_fork: bool,
}

impl AssetRevisionCursor {
    pub fn new(cursor: String, is_fork: bool) -> Self {
        AssetRevisionCursor { cursor, is_fork }
    }
}

const ASSET_REVISION_CURSOR_FIELDS: &[&str] = &["cursor", "is_fork"];
impl AssetRevisionCursor {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetRevisionCursor, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetRevisionCursor>, V::Error> {
        let mut field_cursor = None;
        let mut field_is_fork = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(::serde::de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                "is_fork" => {
                    if field_is_fork.is_some() {
                        return Err(::serde::de::Error::duplicate_field("is_fork"));
                    }
                    field_is_fork = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetRevisionCursor {
            cursor: field_cursor.ok_or_else(|| ::serde::de::Error::missing_field("cursor"))?,
            is_fork: field_is_fork.ok_or_else(|| ::serde::de::Error::missing_field("is_fork"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("cursor", &self.cursor)?;
        s.serialize_field("is_fork", &self.is_fork)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetRevisionCursor {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetRevisionCursor;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetRevisionCursor struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetRevisionCursor::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetRevisionCursor",
            ASSET_REVISION_CURSOR_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetRevisionCursor {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetRevisionCursor", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetRevisionIterArg {
    pub entry_ref: EntryRef,
    pub limit: u32,
    pub direction: RevisionIterDirection,
}

impl AssetRevisionIterArg {
    pub fn new(entry_ref: EntryRef) -> Self {
        AssetRevisionIterArg {
            entry_ref,
            limit: 10,
            direction: RevisionIterDirection::Older,
        }
    }

    pub fn with_limit(mut self, value: u32) -> Self {
        self.limit = value;
        self
    }

    pub fn with_direction(mut self, value: RevisionIterDirection) -> Self {
        self.direction = value;
        self
    }
}

const ASSET_REVISION_ITER_ARG_FIELDS: &[&str] = &["entry_ref", "limit", "direction"];
impl AssetRevisionIterArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetRevisionIterArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetRevisionIterArg>, V::Error> {
        let mut field_entry_ref = None;
        let mut field_limit = None;
        let mut field_direction = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "entry_ref" => {
                    if field_entry_ref.is_some() {
                        return Err(::serde::de::Error::duplicate_field("entry_ref"));
                    }
                    field_entry_ref = Some(map.next_value()?);
                }
                "limit" => {
                    if field_limit.is_some() {
                        return Err(::serde::de::Error::duplicate_field("limit"));
                    }
                    field_limit = Some(map.next_value()?);
                }
                "direction" => {
                    if field_direction.is_some() {
                        return Err(::serde::de::Error::duplicate_field("direction"));
                    }
                    field_direction = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetRevisionIterArg {
            entry_ref: field_entry_ref
                .ok_or_else(|| ::serde::de::Error::missing_field("entry_ref"))?,
            limit: field_limit.unwrap_or(10),
            direction: field_direction.unwrap_or(RevisionIterDirection::Older),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("entry_ref", &self.entry_ref)?;
        if self.limit != 10 {
            s.serialize_field("limit", &self.limit)?;
        }
        if self.direction != RevisionIterDirection::Older {
            s.serialize_field("direction", &self.direction)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetRevisionIterArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetRevisionIterArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetRevisionIterArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetRevisionIterArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetRevisionIterArg",
            ASSET_REVISION_ITER_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetRevisionIterArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetRevisionIterArg", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetRevisionIterError {
    BadEntryRef,
    NoPermission,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetRevisionIterError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetRevisionIterError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetRevisionIterError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_entry_ref" => AssetRevisionIterError::BadEntryRef,
                    "no_permission" => AssetRevisionIterError::NoPermission,
                    _ => AssetRevisionIterError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["bad_entry_ref", "no_permission", "other"];
        deserializer.deserialize_struct("AssetRevisionIterError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetRevisionIterError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetRevisionIterError::BadEntryRef => {
                // unit
                let mut s = serializer.serialize_struct("AssetRevisionIterError", 1)?;
                s.serialize_field(".tag", "bad_entry_ref")?;
                s.end()
            }
            AssetRevisionIterError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetRevisionIterError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetRevisionIterError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetRevisionIterError {}

impl ::std::fmt::Display for AssetRevisionIterError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetRevisionIterNextArg {
    pub cursor: String,
    pub limit: u32,
}

impl AssetRevisionIterNextArg {
    pub fn new(cursor: String) -> Self {
        AssetRevisionIterNextArg { cursor, limit: 10 }
    }

    pub fn with_limit(mut self, value: u32) -> Self {
        self.limit = value;
        self
    }
}

const ASSET_REVISION_ITER_NEXT_ARG_FIELDS: &[&str] = &["cursor", "limit"];
impl AssetRevisionIterNextArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetRevisionIterNextArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetRevisionIterNextArg>, V::Error> {
        let mut field_cursor = None;
        let mut field_limit = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "cursor" => {
                    if field_cursor.is_some() {
                        return Err(::serde::de::Error::duplicate_field("cursor"));
                    }
                    field_cursor = Some(map.next_value()?);
                }
                "limit" => {
                    if field_limit.is_some() {
                        return Err(::serde::de::Error::duplicate_field("limit"));
                    }
                    field_limit = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetRevisionIterNextArg {
            cursor: field_cursor.ok_or_else(|| ::serde::de::Error::missing_field("cursor"))?,
            limit: field_limit.unwrap_or(10),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("cursor", &self.cursor)?;
        if self.limit != 10 {
            s.serialize_field("limit", &self.limit)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetRevisionIterNextArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetRevisionIterNextArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetRevisionIterNextArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetRevisionIterNextArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetRevisionIterNextArg",
            ASSET_REVISION_ITER_NEXT_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetRevisionIterNextArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetRevisionIterNextArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AssetRevisionIterNextError {
    BadCursor,
    NoPermission,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AssetRevisionIterNextError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AssetRevisionIterNextError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetRevisionIterNextError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_cursor" => AssetRevisionIterNextError::BadCursor,
                    "no_permission" => AssetRevisionIterNextError::NoPermission,
                    _ => AssetRevisionIterNextError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["bad_cursor", "no_permission", "other"];
        deserializer.deserialize_struct("AssetRevisionIterNextError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AssetRevisionIterNextError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AssetRevisionIterNextError::BadCursor => {
                // unit
                let mut s = serializer.serialize_struct("AssetRevisionIterNextError", 1)?;
                s.serialize_field(".tag", "bad_cursor")?;
                s.end()
            }
            AssetRevisionIterNextError::NoPermission => {
                // unit
                let mut s = serializer.serialize_struct("AssetRevisionIterNextError", 1)?;
                s.serialize_field(".tag", "no_permission")?;
                s.end()
            }
            AssetRevisionIterNextError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AssetRevisionIterNextError {}

impl ::std::fmt::Display for AssetRevisionIterNextError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AssetRevisionIterResult {
    pub revisions: Vec<AssetRevision>,
    /// Approximate number of revisions remaining including those in `revisions`.
    pub approx_remaining: u32,
    pub next: Option<AssetRevisionCursor>,
}

impl AssetRevisionIterResult {
    pub fn new(revisions: Vec<AssetRevision>, approx_remaining: u32) -> Self {
        AssetRevisionIterResult {
            revisions,
            approx_remaining,
            next: None,
        }
    }

    pub fn with_next(mut self, value: AssetRevisionCursor) -> Self {
        self.next = Some(value);
        self
    }
}

const ASSET_REVISION_ITER_RESULT_FIELDS: &[&str] = &["revisions", "approx_remaining", "next"];
impl AssetRevisionIterResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AssetRevisionIterResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AssetRevisionIterResult>, V::Error> {
        let mut field_revisions = None;
        let mut field_approx_remaining = None;
        let mut field_next = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "revisions" => {
                    if field_revisions.is_some() {
                        return Err(::serde::de::Error::duplicate_field("revisions"));
                    }
                    field_revisions = Some(map.next_value()?);
                }
                "approx_remaining" => {
                    if field_approx_remaining.is_some() {
                        return Err(::serde::de::Error::duplicate_field("approx_remaining"));
                    }
                    field_approx_remaining = Some(map.next_value()?);
                }
                "next" => {
                    if field_next.is_some() {
                        return Err(::serde::de::Error::duplicate_field("next"));
                    }
                    field_next = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AssetRevisionIterResult {
            revisions: field_revisions
                .ok_or_else(|| ::serde::de::Error::missing_field("revisions"))?,
            approx_remaining: field_approx_remaining
                .ok_or_else(|| ::serde::de::Error::missing_field("approx_remaining"))?,
            next: field_next.and_then(Option::flatten),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("revisions", &self.revisions)?;
        s.serialize_field("approx_remaining", &self.approx_remaining)?;
        if let Some(val) = &self.next {
            s.serialize_field("next", val)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AssetRevisionIterResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AssetRevisionIterResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AssetRevisionIterResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AssetRevisionIterResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AssetRevisionIterResult",
            ASSET_REVISION_ITER_RESULT_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AssetRevisionIterResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AssetRevisionIterResult", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

/// Empty placeholder for future proofing.
#[derive(Debug, Clone, PartialEq, Eq, Default)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct ContentEncryptedInfo {}

const CONTENT_ENCRYPTED_INFO_FIELDS: &[&str] = &[];
impl ContentEncryptedInfo {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<ContentEncryptedInfo, V::Error> {
        // ignore any fields found; none are presently recognized
        super::eat_json_fields(&mut map)?;
        Ok(ContentEncryptedInfo {})
    }
}

impl<'de> ::serde::de::Deserialize<'de> for ContentEncryptedInfo {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = ContentEncryptedInfo;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ContentEncryptedInfo struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                ContentEncryptedInfo::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "ContentEncryptedInfo",
            CONTENT_ENCRYPTED_INFO_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for ContentEncryptedInfo {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        serializer
            .serialize_struct("ContentEncryptedInfo", 0)?
            .end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum EntryListOrder {
    Asc,
    Desc,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for EntryListOrder {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = EntryListOrder;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EntryListOrder structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "asc" => EntryListOrder::Asc,
                    "desc" => EntryListOrder::Desc,
                    _ => EntryListOrder::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["asc", "desc", "other"];
        deserializer.deserialize_struct("EntryListOrder", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for EntryListOrder {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            EntryListOrder::Asc => {
                // unit
                let mut s = serializer.serialize_struct("EntryListOrder", 1)?;
                s.serialize_field(".tag", "asc")?;
                s.end()
            }
            EntryListOrder::Desc => {
                // unit
                let mut s = serializer.serialize_struct("EntryListOrder", 1)?;
                s.serialize_field(".tag", "desc")?;
                s.end()
            }
            EntryListOrder::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum EntryRef {
    Name(String),
    EntryId(String),
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for EntryRef {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = EntryRef;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EntryRef structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "name" => match map.next_key()? {
                        Some("name") => EntryRef::Name(map.next_value()?),
                        None => return Err(de::Error::missing_field("name")),
                        _ => return Err(de::Error::unknown_field(tag, VARIANTS)),
                    },
                    "entry_id" => match map.next_key()? {
                        Some("entry_id") => EntryRef::EntryId(map.next_value()?),
                        None => return Err(de::Error::missing_field("entry_id")),
                        _ => return Err(de::Error::unknown_field(tag, VARIANTS)),
                    },
                    _ => EntryRef::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["name", "entry_id", "other"];
        deserializer.deserialize_struct("EntryRef", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for EntryRef {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            EntryRef::Name(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("EntryRef", 2)?;
                s.serialize_field(".tag", "name")?;
                s.serialize_field("name", x)?;
                s.end()
            }
            EntryRef::EntryId(ref x) => {
                // primitive
                let mut s = serializer.serialize_struct("EntryRef", 2)?;
                s.serialize_field(".tag", "entry_id")?;
                s.serialize_field("entry_id", x)?;
                s.end()
            }
            EntryRef::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

/// Policy when the new asset has a [`AssetPutTextArg::name`](AssetPutTextArg) that conflicts with
/// an existing asset.
#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum PutConflictPolicy {
    Reject,
    Override,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for PutConflictPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = PutConflictPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a PutConflictPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "reject" => PutConflictPolicy::Reject,
                    "override" => PutConflictPolicy::Override,
                    _ => PutConflictPolicy::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["reject", "override", "other"];
        deserializer.deserialize_struct("PutConflictPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for PutConflictPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            PutConflictPolicy::Reject => {
                // unit
                let mut s = serializer.serialize_struct("PutConflictPolicy", 1)?;
                s.serialize_field(".tag", "reject")?;
                s.end()
            }
            PutConflictPolicy::Override => {
                // unit
                let mut s = serializer.serialize_struct("PutConflictPolicy", 1)?;
                s.serialize_field(".tag", "override")?;
                s.end()
            }
            PutConflictPolicy::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

/// Policy when [`AssetReplaceArg::rev_id`](AssetReplaceArg) is no longer the most recent for the
/// asset.
#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum ReplaceConflictPolicy {
    Reject,
    Fork,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for ReplaceConflictPolicy {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = ReplaceConflictPolicy;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a ReplaceConflictPolicy structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "reject" => ReplaceConflictPolicy::Reject,
                    "fork" => ReplaceConflictPolicy::Fork,
                    _ => ReplaceConflictPolicy::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["reject", "fork", "other"];
        deserializer.deserialize_struct("ReplaceConflictPolicy", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for ReplaceConflictPolicy {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            ReplaceConflictPolicy::Reject => {
                // unit
                let mut s = serializer.serialize_struct("ReplaceConflictPolicy", 1)?;
                s.serialize_field(".tag", "reject")?;
                s.end()
            }
            ReplaceConflictPolicy::Fork => {
                // unit
                let mut s = serializer.serialize_struct("ReplaceConflictPolicy", 1)?;
                s.serialize_field(".tag", "fork")?;
                s.end()
            }
            ReplaceConflictPolicy::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum RevisionIterDirection {
    Older,
    Newer,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for RevisionIterDirection {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = RevisionIterDirection;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a RevisionIterDirection structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "older" => RevisionIterDirection::Older,
                    "newer" => RevisionIterDirection::Newer,
                    _ => RevisionIterDirection::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["older", "newer", "other"];
        deserializer.deserialize_struct("RevisionIterDirection", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for RevisionIterDirection {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            RevisionIterDirection::Older => {
                // unit
                let mut s = serializer.serialize_struct("RevisionIterDirection", 1)?;
                s.serialize_field(".tag", "older")?;
                s.end()
            }
            RevisionIterDirection::Newer => {
                // unit
                let mut s = serializer.serialize_struct("RevisionIterDirection", 1)?;
                s.serialize_field(".tag", "newer")?;
                s.end()
            }
            RevisionIterDirection::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}
