// DO NOT EDIT
// This file was @generated by Stone

#![allow(
    dead_code,
    clippy::too_many_arguments,
    clippy::too_many_arguments,
    clippy::large_enum_variant,
    clippy::result_large_err,
    clippy::doc_markdown
)]

#[allow(unused_imports)]
use base64::{Engine as _, engine::general_purpose::STANDARD_NO_PAD as BASE64};

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AccountCheckClientVersionResult {
    pub version: String,
}

impl AccountCheckClientVersionResult {
    pub fn new(version: String) -> Self {
        AccountCheckClientVersionResult { version }
    }
}

const ACCOUNT_CHECK_CLIENT_VERSION_RESULT_FIELDS: &[&str] = &["version"];
impl AccountCheckClientVersionResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AccountCheckClientVersionResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AccountCheckClientVersionResult>, V::Error> {
        let mut field_version = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "version" => {
                    if field_version.is_some() {
                        return Err(::serde::de::Error::duplicate_field("version"));
                    }
                    field_version = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AccountCheckClientVersionResult {
            version: field_version.ok_or_else(|| ::serde::de::Error::missing_field("version"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("version", &self.version)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountCheckClientVersionResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountCheckClientVersionResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountCheckClientVersionResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountCheckClientVersionResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AccountCheckClientVersionResult",
            ACCOUNT_CHECK_CLIENT_VERSION_RESULT_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AccountCheckClientVersionResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountCheckClientVersionResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AccountGetBalanceResult {
    /// Remaining account balance, represented in US dollars as cents (e.g., $1.23 is represented as
    /// 123).
    pub remaining: i32,
}

impl AccountGetBalanceResult {
    pub fn new(remaining: i32) -> Self {
        AccountGetBalanceResult { remaining }
    }
}

const ACCOUNT_GET_BALANCE_RESULT_FIELDS: &[&str] = &["remaining"];
impl AccountGetBalanceResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AccountGetBalanceResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AccountGetBalanceResult>, V::Error> {
        let mut field_remaining = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "remaining" => {
                    if field_remaining.is_some() {
                        return Err(::serde::de::Error::duplicate_field("remaining"));
                    }
                    field_remaining = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AccountGetBalanceResult {
            remaining: field_remaining
                .ok_or_else(|| ::serde::de::Error::missing_field("remaining"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("remaining", &self.remaining)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountGetBalanceResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountGetBalanceResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountGetBalanceResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountGetBalanceResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AccountGetBalanceResult",
            ACCOUNT_GET_BALANCE_RESULT_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AccountGetBalanceResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountGetBalanceResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AccountGetSubscribeLinkError {
    AlreadySubscribed,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AccountGetSubscribeLinkError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AccountGetSubscribeLinkError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountGetSubscribeLinkError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "already_subscribed" => AccountGetSubscribeLinkError::AlreadySubscribed,
                    _ => AccountGetSubscribeLinkError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["already_subscribed", "other"];
        deserializer.deserialize_struct("AccountGetSubscribeLinkError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AccountGetSubscribeLinkError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AccountGetSubscribeLinkError::AlreadySubscribed => {
                // unit
                let mut s = serializer.serialize_struct("AccountGetSubscribeLinkError", 1)?;
                s.serialize_field(".tag", "already_subscribed")?;
                s.end()
            }
            AccountGetSubscribeLinkError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AccountGetSubscribeLinkError {}

impl ::std::fmt::Display for AccountGetSubscribeLinkError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AccountGetSubscribeLinkResult {
    pub subscribe_link: String,
}

impl AccountGetSubscribeLinkResult {
    pub fn new(subscribe_link: String) -> Self {
        AccountGetSubscribeLinkResult { subscribe_link }
    }
}

const ACCOUNT_GET_SUBSCRIBE_LINK_RESULT_FIELDS: &[&str] = &["subscribe_link"];
impl AccountGetSubscribeLinkResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AccountGetSubscribeLinkResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AccountGetSubscribeLinkResult>, V::Error> {
        let mut field_subscribe_link = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "subscribe_link" => {
                    if field_subscribe_link.is_some() {
                        return Err(::serde::de::Error::duplicate_field("subscribe_link"));
                    }
                    field_subscribe_link = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AccountGetSubscribeLinkResult {
            subscribe_link: field_subscribe_link
                .ok_or_else(|| ::serde::de::Error::missing_field("subscribe_link"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("subscribe_link", &self.subscribe_link)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountGetSubscribeLinkResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountGetSubscribeLinkResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountGetSubscribeLinkResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountGetSubscribeLinkResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AccountGetSubscribeLinkResult",
            ACCOUNT_GET_SUBSCRIBE_LINK_RESULT_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AccountGetSubscribeLinkResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountGetSubscribeLinkResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AccountRegisterArg {
    pub username: String,
    pub password: String,
    pub email: Option<String>,
}

impl AccountRegisterArg {
    pub fn new(username: String, password: String) -> Self {
        AccountRegisterArg {
            username,
            password,
            email: None,
        }
    }

    pub fn with_email(mut self, value: String) -> Self {
        self.email = Some(value);
        self
    }
}

const ACCOUNT_REGISTER_ARG_FIELDS: &[&str] = &["username", "password", "email"];
impl AccountRegisterArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AccountRegisterArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AccountRegisterArg>, V::Error> {
        let mut field_username = None;
        let mut field_password = None;
        let mut field_email = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "username" => {
                    if field_username.is_some() {
                        return Err(::serde::de::Error::duplicate_field("username"));
                    }
                    field_username = Some(map.next_value()?);
                }
                "password" => {
                    if field_password.is_some() {
                        return Err(::serde::de::Error::duplicate_field("password"));
                    }
                    field_password = Some(map.next_value()?);
                }
                "email" => {
                    if field_email.is_some() {
                        return Err(::serde::de::Error::duplicate_field("email"));
                    }
                    field_email = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AccountRegisterArg {
            username: field_username
                .ok_or_else(|| ::serde::de::Error::missing_field("username"))?,
            password: field_password
                .ok_or_else(|| ::serde::de::Error::missing_field("password"))?,
            email: field_email.and_then(Option::flatten),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("username", &self.username)?;
        s.serialize_field("password", &self.password)?;
        if let Some(val) = &self.email {
            s.serialize_field("email", val)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountRegisterArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountRegisterArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountRegisterArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountRegisterArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AccountRegisterArg",
            ACCOUNT_REGISTER_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AccountRegisterArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountRegisterArg", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AccountRegisterError {
    /// [`AccountRegisterArg::username`](AccountRegisterArg) is not a valid username.
    BadUsername,
    /// [`AccountRegisterArg::username`](AccountRegisterArg) is already registered.
    UsernameTaken,
    BadPassword,
    /// [`AccountRegisterArg::email`](AccountRegisterArg) is not a valid email.
    BadEmail,
    /// [`AccountRegisterArg::email`](AccountRegisterArg) address is already registered.
    EmailTaken,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AccountRegisterError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AccountRegisterError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountRegisterError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_username" => AccountRegisterError::BadUsername,
                    "username_taken" => AccountRegisterError::UsernameTaken,
                    "bad_password" => AccountRegisterError::BadPassword,
                    "bad_email" => AccountRegisterError::BadEmail,
                    "email_taken" => AccountRegisterError::EmailTaken,
                    _ => AccountRegisterError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &[
            "bad_username",
            "username_taken",
            "bad_password",
            "bad_email",
            "email_taken",
            "other",
        ];
        deserializer.deserialize_struct("AccountRegisterError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AccountRegisterError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AccountRegisterError::BadUsername => {
                // unit
                let mut s = serializer.serialize_struct("AccountRegisterError", 1)?;
                s.serialize_field(".tag", "bad_username")?;
                s.end()
            }
            AccountRegisterError::UsernameTaken => {
                // unit
                let mut s = serializer.serialize_struct("AccountRegisterError", 1)?;
                s.serialize_field(".tag", "username_taken")?;
                s.end()
            }
            AccountRegisterError::BadPassword => {
                // unit
                let mut s = serializer.serialize_struct("AccountRegisterError", 1)?;
                s.serialize_field(".tag", "bad_password")?;
                s.end()
            }
            AccountRegisterError::BadEmail => {
                // unit
                let mut s = serializer.serialize_struct("AccountRegisterError", 1)?;
                s.serialize_field(".tag", "bad_email")?;
                s.end()
            }
            AccountRegisterError::EmailTaken => {
                // unit
                let mut s = serializer.serialize_struct("AccountRegisterError", 1)?;
                s.serialize_field(".tag", "email_taken")?;
                s.end()
            }
            AccountRegisterError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AccountRegisterError {}

impl ::std::fmt::Display for AccountRegisterError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AccountRegisterResult {
    pub user_id: String,
    pub username: String,
    pub token: String,
}

impl AccountRegisterResult {
    pub fn new(user_id: String, username: String, token: String) -> Self {
        AccountRegisterResult {
            user_id,
            username,
            token,
        }
    }
}

const ACCOUNT_REGISTER_RESULT_FIELDS: &[&str] = &["user_id", "username", "token"];
impl AccountRegisterResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AccountRegisterResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AccountRegisterResult>, V::Error> {
        let mut field_user_id = None;
        let mut field_username = None;
        let mut field_token = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "user_id" => {
                    if field_user_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("user_id"));
                    }
                    field_user_id = Some(map.next_value()?);
                }
                "username" => {
                    if field_username.is_some() {
                        return Err(::serde::de::Error::duplicate_field("username"));
                    }
                    field_username = Some(map.next_value()?);
                }
                "token" => {
                    if field_token.is_some() {
                        return Err(::serde::de::Error::duplicate_field("token"));
                    }
                    field_token = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AccountRegisterResult {
            user_id: field_user_id.ok_or_else(|| ::serde::de::Error::missing_field("user_id"))?,
            username: field_username
                .ok_or_else(|| ::serde::de::Error::missing_field("username"))?,
            token: field_token.ok_or_else(|| ::serde::de::Error::missing_field("token"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("user_id", &self.user_id)?;
        s.serialize_field("username", &self.username)?;
        s.serialize_field("token", &self.token)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountRegisterResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountRegisterResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountRegisterResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountRegisterResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AccountRegisterResult",
            ACCOUNT_REGISTER_RESULT_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AccountRegisterResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountRegisterResult", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Default)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AccountSetBioArg {
    /// If unset, clears bio.
    pub bio: Option<String>,
}

impl AccountSetBioArg {
    pub fn with_bio(mut self, value: String) -> Self {
        self.bio = Some(value);
        self
    }
}

const ACCOUNT_SET_BIO_ARG_FIELDS: &[&str] = &["bio"];
impl AccountSetBioArg {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AccountSetBioArg, V::Error> {
        let mut field_bio = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "bio" => {
                    if field_bio.is_some() {
                        return Err(::serde::de::Error::duplicate_field("bio"));
                    }
                    field_bio = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = AccountSetBioArg {
            bio: field_bio.and_then(Option::flatten),
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        if let Some(val) = &self.bio {
            s.serialize_field("bio", val)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountSetBioArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountSetBioArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountSetBioArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountSetBioArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AccountSetBioArg",
            ACCOUNT_SET_BIO_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AccountSetBioArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountSetBioArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AccountSetBioError {
    BadBio,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AccountSetBioError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AccountSetBioError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountSetBioError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_bio" => AccountSetBioError::BadBio,
                    _ => AccountSetBioError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["bad_bio", "other"];
        deserializer.deserialize_struct("AccountSetBioError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AccountSetBioError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AccountSetBioError::BadBio => {
                // unit
                let mut s = serializer.serialize_struct("AccountSetBioError", 1)?;
                s.serialize_field(".tag", "bad_bio")?;
                s.end()
            }
            AccountSetBioError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AccountSetBioError {}

impl ::std::fmt::Display for AccountSetBioError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Default)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AccountSetNameArg {
    /// If unset, clears name.
    pub name: Option<String>,
}

impl AccountSetNameArg {
    pub fn with_name(mut self, value: String) -> Self {
        self.name = Some(value);
        self
    }
}

const ACCOUNT_SET_NAME_ARG_FIELDS: &[&str] = &["name"];
impl AccountSetNameArg {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<AccountSetNameArg, V::Error> {
        let mut field_name = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "name" => {
                    if field_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = AccountSetNameArg {
            name: field_name.and_then(Option::flatten),
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        if let Some(val) = &self.name {
            s.serialize_field("name", val)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountSetNameArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountSetNameArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountSetNameArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountSetNameArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AccountSetNameArg",
            ACCOUNT_SET_NAME_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AccountSetNameArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountSetNameArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AccountSetNameError {
    BadName,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AccountSetNameError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AccountSetNameError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountSetNameError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_name" => AccountSetNameError::BadName,
                    _ => AccountSetNameError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["bad_name", "other"];
        deserializer.deserialize_struct("AccountSetNameError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AccountSetNameError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AccountSetNameError::BadName => {
                // unit
                let mut s = serializer.serialize_struct("AccountSetNameError", 1)?;
                s.serialize_field(".tag", "bad_name")?;
                s.end()
            }
            AccountSetNameError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AccountSetNameError {}

impl ::std::fmt::Display for AccountSetNameError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AccountTokenFromLoginArg {
    pub username: String,
    pub password: String,
}

impl AccountTokenFromLoginArg {
    pub fn new(username: String, password: String) -> Self {
        AccountTokenFromLoginArg { username, password }
    }
}

const ACCOUNT_TOKEN_FROM_LOGIN_ARG_FIELDS: &[&str] = &["username", "password"];
impl AccountTokenFromLoginArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AccountTokenFromLoginArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AccountTokenFromLoginArg>, V::Error> {
        let mut field_username = None;
        let mut field_password = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "username" => {
                    if field_username.is_some() {
                        return Err(::serde::de::Error::duplicate_field("username"));
                    }
                    field_username = Some(map.next_value()?);
                }
                "password" => {
                    if field_password.is_some() {
                        return Err(::serde::de::Error::duplicate_field("password"));
                    }
                    field_password = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AccountTokenFromLoginArg {
            username: field_username
                .ok_or_else(|| ::serde::de::Error::missing_field("username"))?,
            password: field_password
                .ok_or_else(|| ::serde::de::Error::missing_field("password"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("username", &self.username)?;
        s.serialize_field("password", &self.password)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountTokenFromLoginArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountTokenFromLoginArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountTokenFromLoginArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountTokenFromLoginArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AccountTokenFromLoginArg",
            ACCOUNT_TOKEN_FROM_LOGIN_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AccountTokenFromLoginArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountTokenFromLoginArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AccountTokenFromLoginError {
    BadPassword,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AccountTokenFromLoginError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AccountTokenFromLoginError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountTokenFromLoginError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_password" => AccountTokenFromLoginError::BadPassword,
                    _ => AccountTokenFromLoginError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["bad_password", "other"];
        deserializer.deserialize_struct("AccountTokenFromLoginError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AccountTokenFromLoginError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AccountTokenFromLoginError::BadPassword => {
                // unit
                let mut s = serializer.serialize_struct("AccountTokenFromLoginError", 1)?;
                s.serialize_field(".tag", "bad_password")?;
                s.end()
            }
            AccountTokenFromLoginError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AccountTokenFromLoginError {}

impl ::std::fmt::Display for AccountTokenFromLoginError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AccountTokenFromLoginResult {
    pub user_id: String,
    pub username: String,
    pub token: String,
}

impl AccountTokenFromLoginResult {
    pub fn new(user_id: String, username: String, token: String) -> Self {
        AccountTokenFromLoginResult {
            user_id,
            username,
            token,
        }
    }
}

const ACCOUNT_TOKEN_FROM_LOGIN_RESULT_FIELDS: &[&str] = &["user_id", "username", "token"];
impl AccountTokenFromLoginResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AccountTokenFromLoginResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AccountTokenFromLoginResult>, V::Error> {
        let mut field_user_id = None;
        let mut field_username = None;
        let mut field_token = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "user_id" => {
                    if field_user_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("user_id"));
                    }
                    field_user_id = Some(map.next_value()?);
                }
                "username" => {
                    if field_username.is_some() {
                        return Err(::serde::de::Error::duplicate_field("username"));
                    }
                    field_username = Some(map.next_value()?);
                }
                "token" => {
                    if field_token.is_some() {
                        return Err(::serde::de::Error::duplicate_field("token"));
                    }
                    field_token = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AccountTokenFromLoginResult {
            user_id: field_user_id.ok_or_else(|| ::serde::de::Error::missing_field("user_id"))?,
            username: field_username
                .ok_or_else(|| ::serde::de::Error::missing_field("username"))?,
            token: field_token.ok_or_else(|| ::serde::de::Error::missing_field("token"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("user_id", &self.user_id)?;
        s.serialize_field("username", &self.username)?;
        s.serialize_field("token", &self.token)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountTokenFromLoginResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountTokenFromLoginResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountTokenFromLoginResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountTokenFromLoginResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AccountTokenFromLoginResult",
            ACCOUNT_TOKEN_FROM_LOGIN_RESULT_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AccountTokenFromLoginResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountTokenFromLoginResult", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AccountWhoisArg {
    pub username: String,
}

impl AccountWhoisArg {
    pub fn new(username: String) -> Self {
        AccountWhoisArg { username }
    }
}

const ACCOUNT_WHOIS_ARG_FIELDS: &[&str] = &["username"];
impl AccountWhoisArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AccountWhoisArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AccountWhoisArg>, V::Error> {
        let mut field_username = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "username" => {
                    if field_username.is_some() {
                        return Err(::serde::de::Error::duplicate_field("username"));
                    }
                    field_username = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AccountWhoisArg {
            username: field_username
                .ok_or_else(|| ::serde::de::Error::missing_field("username"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("username", &self.username)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountWhoisArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountWhoisArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountWhoisArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountWhoisArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("AccountWhoisArg", ACCOUNT_WHOIS_ARG_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for AccountWhoisArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountWhoisArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum AccountWhoisError {
    UserNotFound,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for AccountWhoisError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = AccountWhoisError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountWhoisError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "user_not_found" => AccountWhoisError::UserNotFound,
                    _ => AccountWhoisError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["user_not_found", "other"];
        deserializer.deserialize_struct("AccountWhoisError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for AccountWhoisError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            AccountWhoisError::UserNotFound => {
                // unit
                let mut s = serializer.serialize_struct("AccountWhoisError", 1)?;
                s.serialize_field(".tag", "user_not_found")?;
                s.end()
            }
            AccountWhoisError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for AccountWhoisError {}

impl ::std::fmt::Display for AccountWhoisError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct AccountWhoisResult {
    pub user_id: String,
    pub username: String,
    pub joined_on: super::common::UtcTimestamp,
    pub tasks: Vec<TaskShort>,
    pub name: Option<String>,
    pub bio: Option<String>,
}

impl AccountWhoisResult {
    pub fn new(
        user_id: String,
        username: String,
        joined_on: super::common::UtcTimestamp,
        tasks: Vec<TaskShort>,
    ) -> Self {
        AccountWhoisResult {
            user_id,
            username,
            joined_on,
            tasks,
            name: None,
            bio: None,
        }
    }

    pub fn with_name(mut self, value: String) -> Self {
        self.name = Some(value);
        self
    }

    pub fn with_bio(mut self, value: String) -> Self {
        self.bio = Some(value);
        self
    }
}

const ACCOUNT_WHOIS_RESULT_FIELDS: &[&str] =
    &["user_id", "username", "joined_on", "tasks", "name", "bio"];
impl AccountWhoisResult {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<AccountWhoisResult, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<AccountWhoisResult>, V::Error> {
        let mut field_user_id = None;
        let mut field_username = None;
        let mut field_joined_on = None;
        let mut field_tasks = None;
        let mut field_name = None;
        let mut field_bio = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "user_id" => {
                    if field_user_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("user_id"));
                    }
                    field_user_id = Some(map.next_value()?);
                }
                "username" => {
                    if field_username.is_some() {
                        return Err(::serde::de::Error::duplicate_field("username"));
                    }
                    field_username = Some(map.next_value()?);
                }
                "joined_on" => {
                    if field_joined_on.is_some() {
                        return Err(::serde::de::Error::duplicate_field("joined_on"));
                    }
                    field_joined_on = Some(map.next_value()?);
                }
                "tasks" => {
                    if field_tasks.is_some() {
                        return Err(::serde::de::Error::duplicate_field("tasks"));
                    }
                    field_tasks = Some(map.next_value()?);
                }
                "name" => {
                    if field_name.is_some() {
                        return Err(::serde::de::Error::duplicate_field("name"));
                    }
                    field_name = Some(map.next_value()?);
                }
                "bio" => {
                    if field_bio.is_some() {
                        return Err(::serde::de::Error::duplicate_field("bio"));
                    }
                    field_bio = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = AccountWhoisResult {
            user_id: field_user_id.ok_or_else(|| ::serde::de::Error::missing_field("user_id"))?,
            username: field_username
                .ok_or_else(|| ::serde::de::Error::missing_field("username"))?,
            joined_on: field_joined_on
                .ok_or_else(|| ::serde::de::Error::missing_field("joined_on"))?,
            tasks: field_tasks.ok_or_else(|| ::serde::de::Error::missing_field("tasks"))?,
            name: field_name.and_then(Option::flatten),
            bio: field_bio.and_then(Option::flatten),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("user_id", &self.user_id)?;
        s.serialize_field("username", &self.username)?;
        s.serialize_field("joined_on", &self.joined_on)?;
        s.serialize_field("tasks", &self.tasks)?;
        if let Some(val) = &self.name {
            s.serialize_field("name", val)?;
        }
        if let Some(val) = &self.bio {
            s.serialize_field("bio", val)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for AccountWhoisResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = AccountWhoisResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a AccountWhoisResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                AccountWhoisResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "AccountWhoisResult",
            ACCOUNT_WHOIS_RESULT_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for AccountWhoisResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("AccountWhoisResult", 6)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct TaskShort {
    pub task_id: String,
    pub task_fqn: String,
}

impl TaskShort {
    pub fn new(task_id: String, task_fqn: String) -> Self {
        TaskShort { task_id, task_fqn }
    }
}

const TASK_SHORT_FIELDS: &[&str] = &["task_id", "task_fqn"];
impl TaskShort {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<TaskShort, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<TaskShort>, V::Error> {
        let mut field_task_id = None;
        let mut field_task_fqn = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "task_id" => {
                    if field_task_id.is_some() {
                        return Err(::serde::de::Error::duplicate_field("task_id"));
                    }
                    field_task_id = Some(map.next_value()?);
                }
                "task_fqn" => {
                    if field_task_fqn.is_some() {
                        return Err(::serde::de::Error::duplicate_field("task_fqn"));
                    }
                    field_task_fqn = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = TaskShort {
            task_id: field_task_id.ok_or_else(|| ::serde::de::Error::missing_field("task_id"))?,
            task_fqn: field_task_fqn
                .ok_or_else(|| ::serde::de::Error::missing_field("task_fqn"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("task_id", &self.task_id)?;
        s.serialize_field("task_fqn", &self.task_fqn)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for TaskShort {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = TaskShort;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a TaskShort struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                TaskShort::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct("TaskShort", TASK_SHORT_FIELDS, StructVisitor)
    }
}

impl ::serde::ser::Serialize for TaskShort {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("TaskShort", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}
