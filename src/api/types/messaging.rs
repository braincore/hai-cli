// DO NOT EDIT
// This file was @generated by Stone

#![allow(
    dead_code,
    clippy::too_many_arguments,
    clippy::too_many_arguments,
    clippy::large_enum_variant,
    clippy::result_large_err,
    clippy::doc_markdown
)]

#[allow(unused_imports)]
use base64::{Engine as _, engine::general_purpose::STANDARD_NO_PAD as BASE64};

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct EmailRecipientAddArg {
    pub email: String,
}

impl EmailRecipientAddArg {
    pub fn new(email: String) -> Self {
        EmailRecipientAddArg { email }
    }
}

const EMAIL_RECIPIENT_ADD_ARG_FIELDS: &[&str] = &["email"];
impl EmailRecipientAddArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<EmailRecipientAddArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<EmailRecipientAddArg>, V::Error> {
        let mut field_email = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "email" => {
                    if field_email.is_some() {
                        return Err(::serde::de::Error::duplicate_field("email"));
                    }
                    field_email = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = EmailRecipientAddArg {
            email: field_email.ok_or_else(|| ::serde::de::Error::missing_field("email"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("email", &self.email)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmailRecipientAddArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmailRecipientAddArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EmailRecipientAddArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmailRecipientAddArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "EmailRecipientAddArg",
            EMAIL_RECIPIENT_ADD_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for EmailRecipientAddArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EmailRecipientAddArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum EmailRecipientAddError {
    /// [`EmailRecipientAddArg::email`](EmailRecipientAddArg) is not a valid email.
    BadEmail,
    /// [`EmailRecipientAddArg::email`](EmailRecipientAddArg) is already verified
    AlreadyVerified,
    /// The active account has too many email recipients.
    TooManyRecipients,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for EmailRecipientAddError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = EmailRecipientAddError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EmailRecipientAddError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_email" => EmailRecipientAddError::BadEmail,
                    "already_verified" => EmailRecipientAddError::AlreadyVerified,
                    "too_many_recipients" => EmailRecipientAddError::TooManyRecipients,
                    _ => EmailRecipientAddError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &[
            "bad_email",
            "already_verified",
            "too_many_recipients",
            "other",
        ];
        deserializer.deserialize_struct("EmailRecipientAddError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for EmailRecipientAddError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            EmailRecipientAddError::BadEmail => {
                // unit
                let mut s = serializer.serialize_struct("EmailRecipientAddError", 1)?;
                s.serialize_field(".tag", "bad_email")?;
                s.end()
            }
            EmailRecipientAddError::AlreadyVerified => {
                // unit
                let mut s = serializer.serialize_struct("EmailRecipientAddError", 1)?;
                s.serialize_field(".tag", "already_verified")?;
                s.end()
            }
            EmailRecipientAddError::TooManyRecipients => {
                // unit
                let mut s = serializer.serialize_struct("EmailRecipientAddError", 1)?;
                s.serialize_field(".tag", "too_many_recipients")?;
                s.end()
            }
            EmailRecipientAddError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for EmailRecipientAddError {}

impl ::std::fmt::Display for EmailRecipientAddError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            EmailRecipientAddError::TooManyRecipients => {
                f.write_str("The active account has too many email recipients.")
            }
            _ => write!(f, "{:?}", *self),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Default)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct EmailRecipientGetDefaultResult {
    /// Unset if no default
    pub email: Option<String>,
}

impl EmailRecipientGetDefaultResult {
    pub fn with_email(mut self, value: String) -> Self {
        self.email = Some(value);
        self
    }
}

const EMAIL_RECIPIENT_GET_DEFAULT_RESULT_FIELDS: &[&str] = &["email"];
impl EmailRecipientGetDefaultResult {
    // no _opt deserializer
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
    ) -> Result<EmailRecipientGetDefaultResult, V::Error> {
        let mut field_email = None;
        while let Some(key) = map.next_key::<&str>()? {
            match key {
                "email" => {
                    if field_email.is_some() {
                        return Err(::serde::de::Error::duplicate_field("email"));
                    }
                    field_email = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        let result = EmailRecipientGetDefaultResult {
            email: field_email.and_then(Option::flatten),
        };
        Ok(result)
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        if let Some(val) = &self.email {
            s.serialize_field("email", val)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmailRecipientGetDefaultResult {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmailRecipientGetDefaultResult;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EmailRecipientGetDefaultResult struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmailRecipientGetDefaultResult::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "EmailRecipientGetDefaultResult",
            EMAIL_RECIPIENT_GET_DEFAULT_RESULT_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for EmailRecipientGetDefaultResult {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EmailRecipientGetDefaultResult", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct EmailRecipientSendArg {
    /// The subject of the email.
    pub subject: String,
    /// If unset, uses default email.
    pub email: Option<String>,
    /// The optional body of the email.
    pub body: Option<String>,
}

impl EmailRecipientSendArg {
    pub fn new(subject: String) -> Self {
        EmailRecipientSendArg {
            subject,
            email: None,
            body: None,
        }
    }

    pub fn with_email(mut self, value: String) -> Self {
        self.email = Some(value);
        self
    }

    pub fn with_body(mut self, value: String) -> Self {
        self.body = Some(value);
        self
    }
}

const EMAIL_RECIPIENT_SEND_ARG_FIELDS: &[&str] = &["subject", "email", "body"];
impl EmailRecipientSendArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<EmailRecipientSendArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<EmailRecipientSendArg>, V::Error> {
        let mut field_subject = None;
        let mut field_email = None;
        let mut field_body = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "subject" => {
                    if field_subject.is_some() {
                        return Err(::serde::de::Error::duplicate_field("subject"));
                    }
                    field_subject = Some(map.next_value()?);
                }
                "email" => {
                    if field_email.is_some() {
                        return Err(::serde::de::Error::duplicate_field("email"));
                    }
                    field_email = Some(map.next_value()?);
                }
                "body" => {
                    if field_body.is_some() {
                        return Err(::serde::de::Error::duplicate_field("body"));
                    }
                    field_body = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = EmailRecipientSendArg {
            subject: field_subject.ok_or_else(|| ::serde::de::Error::missing_field("subject"))?,
            email: field_email.and_then(Option::flatten),
            body: field_body.and_then(Option::flatten),
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("subject", &self.subject)?;
        if let Some(val) = &self.email {
            s.serialize_field("email", val)?;
        }
        if let Some(val) = &self.body {
            s.serialize_field("body", val)?;
        }
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmailRecipientSendArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmailRecipientSendArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EmailRecipientSendArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmailRecipientSendArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "EmailRecipientSendArg",
            EMAIL_RECIPIENT_SEND_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for EmailRecipientSendArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EmailRecipientSendArg", 3)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum EmailRecipientSendError {
    BadEmail,
    /// [`EmailRecipientSendArg::email`](EmailRecipientSendArg) is unset and the active account does
    /// not have a default email recipient.
    NoDefaultRecipient,
    /// The email address has not been verified with
    /// [`email_recipient_verify()`](crate::messaging::email_recipient_verify).
    Unverified,
    /// The active account has sent too many emails to this recipient.
    LimitExceeded,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for EmailRecipientSendError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = EmailRecipientSendError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EmailRecipientSendError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_email" => EmailRecipientSendError::BadEmail,
                    "no_default_recipient" => EmailRecipientSendError::NoDefaultRecipient,
                    "unverified" => EmailRecipientSendError::Unverified,
                    "limit_exceeded" => EmailRecipientSendError::LimitExceeded,
                    _ => EmailRecipientSendError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &[
            "bad_email",
            "no_default_recipient",
            "unverified",
            "limit_exceeded",
            "other",
        ];
        deserializer.deserialize_struct("EmailRecipientSendError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for EmailRecipientSendError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            EmailRecipientSendError::BadEmail => {
                // unit
                let mut s = serializer.serialize_struct("EmailRecipientSendError", 1)?;
                s.serialize_field(".tag", "bad_email")?;
                s.end()
            }
            EmailRecipientSendError::NoDefaultRecipient => {
                // unit
                let mut s = serializer.serialize_struct("EmailRecipientSendError", 1)?;
                s.serialize_field(".tag", "no_default_recipient")?;
                s.end()
            }
            EmailRecipientSendError::Unverified => {
                // unit
                let mut s = serializer.serialize_struct("EmailRecipientSendError", 1)?;
                s.serialize_field(".tag", "unverified")?;
                s.end()
            }
            EmailRecipientSendError::LimitExceeded => {
                // unit
                let mut s = serializer.serialize_struct("EmailRecipientSendError", 1)?;
                s.serialize_field(".tag", "limit_exceeded")?;
                s.end()
            }
            EmailRecipientSendError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for EmailRecipientSendError {}

impl ::std::fmt::Display for EmailRecipientSendError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            EmailRecipientSendError::LimitExceeded => {
                f.write_str("The active account has sent too many emails to this recipient.")
            }
            _ => write!(f, "{:?}", *self),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct EmailRecipientSetDefaultArg {
    pub email: String,
}

impl EmailRecipientSetDefaultArg {
    pub fn new(email: String) -> Self {
        EmailRecipientSetDefaultArg { email }
    }
}

const EMAIL_RECIPIENT_SET_DEFAULT_ARG_FIELDS: &[&str] = &["email"];
impl EmailRecipientSetDefaultArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<EmailRecipientSetDefaultArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<EmailRecipientSetDefaultArg>, V::Error> {
        let mut field_email = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "email" => {
                    if field_email.is_some() {
                        return Err(::serde::de::Error::duplicate_field("email"));
                    }
                    field_email = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = EmailRecipientSetDefaultArg {
            email: field_email.ok_or_else(|| ::serde::de::Error::missing_field("email"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("email", &self.email)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmailRecipientSetDefaultArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmailRecipientSetDefaultArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EmailRecipientSetDefaultArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmailRecipientSetDefaultArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "EmailRecipientSetDefaultArg",
            EMAIL_RECIPIENT_SET_DEFAULT_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for EmailRecipientSetDefaultArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EmailRecipientSetDefaultArg", 1)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum EmailRecipientSetDefaultError {
    BadEmail,
    Unverified,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for EmailRecipientSetDefaultError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = EmailRecipientSetDefaultError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EmailRecipientSetDefaultError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_email" => EmailRecipientSetDefaultError::BadEmail,
                    "unverified" => EmailRecipientSetDefaultError::Unverified,
                    _ => EmailRecipientSetDefaultError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["bad_email", "unverified", "other"];
        deserializer.deserialize_struct("EmailRecipientSetDefaultError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for EmailRecipientSetDefaultError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            EmailRecipientSetDefaultError::BadEmail => {
                // unit
                let mut s = serializer.serialize_struct("EmailRecipientSetDefaultError", 1)?;
                s.serialize_field(".tag", "bad_email")?;
                s.end()
            }
            EmailRecipientSetDefaultError::Unverified => {
                // unit
                let mut s = serializer.serialize_struct("EmailRecipientSetDefaultError", 1)?;
                s.serialize_field(".tag", "unverified")?;
                s.end()
            }
            EmailRecipientSetDefaultError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for EmailRecipientSetDefaultError {}

impl ::std::fmt::Display for EmailRecipientSetDefaultError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // structs may have more fields added in the future.
pub struct EmailRecipientVerifyArg {
    pub email: String,
    pub code: String,
}

impl EmailRecipientVerifyArg {
    pub fn new(email: String, code: String) -> Self {
        EmailRecipientVerifyArg { email, code }
    }
}

const EMAIL_RECIPIENT_VERIFY_ARG_FIELDS: &[&str] = &["email", "code"];
impl EmailRecipientVerifyArg {
    pub(crate) fn internal_deserialize<'de, V: ::serde::de::MapAccess<'de>>(
        map: V,
    ) -> Result<EmailRecipientVerifyArg, V::Error> {
        Self::internal_deserialize_opt(map, false).map(Option::unwrap)
    }

    pub(crate) fn internal_deserialize_opt<'de, V: ::serde::de::MapAccess<'de>>(
        mut map: V,
        optional: bool,
    ) -> Result<Option<EmailRecipientVerifyArg>, V::Error> {
        let mut field_email = None;
        let mut field_code = None;
        let mut nothing = true;
        while let Some(key) = map.next_key::<&str>()? {
            nothing = false;
            match key {
                "email" => {
                    if field_email.is_some() {
                        return Err(::serde::de::Error::duplicate_field("email"));
                    }
                    field_email = Some(map.next_value()?);
                }
                "code" => {
                    if field_code.is_some() {
                        return Err(::serde::de::Error::duplicate_field("code"));
                    }
                    field_code = Some(map.next_value()?);
                }
                _ => {
                    // unknown field allowed and ignored
                    map.next_value::<::serde_json::Value>()?;
                }
            }
        }
        if optional && nothing {
            return Ok(None);
        }
        let result = EmailRecipientVerifyArg {
            email: field_email.ok_or_else(|| ::serde::de::Error::missing_field("email"))?,
            code: field_code.ok_or_else(|| ::serde::de::Error::missing_field("code"))?,
        };
        Ok(Some(result))
    }

    pub(crate) fn internal_serialize<S: ::serde::ser::Serializer>(
        &self,
        s: &mut S::SerializeStruct,
    ) -> Result<(), S::Error> {
        use serde::ser::SerializeStruct;
        s.serialize_field("email", &self.email)?;
        s.serialize_field("code", &self.code)?;
        Ok(())
    }
}

impl<'de> ::serde::de::Deserialize<'de> for EmailRecipientVerifyArg {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // struct deserializer
        use serde::de::{MapAccess, Visitor};
        struct StructVisitor;
        impl<'de> Visitor<'de> for StructVisitor {
            type Value = EmailRecipientVerifyArg;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EmailRecipientVerifyArg struct")
            }
            fn visit_map<V: MapAccess<'de>>(self, map: V) -> Result<Self::Value, V::Error> {
                EmailRecipientVerifyArg::internal_deserialize(map)
            }
        }
        deserializer.deserialize_struct(
            "EmailRecipientVerifyArg",
            EMAIL_RECIPIENT_VERIFY_ARG_FIELDS,
            StructVisitor,
        )
    }
}

impl ::serde::ser::Serialize for EmailRecipientVerifyArg {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // struct serializer
        use serde::ser::SerializeStruct;
        let mut s = serializer.serialize_struct("EmailRecipientVerifyArg", 2)?;
        self.internal_serialize::<S>(&mut s)?;
        s.end()
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[non_exhaustive] // variants may be added in the future
pub enum EmailRecipientVerifyError {
    BadEmail,
    ExpiredCode,
    BadCode,
    /// Catch-all used for unrecognized values returned from the server. Encountering this value
    /// typically indicates that this SDK version is out of date.
    Other,
}

impl<'de> ::serde::de::Deserialize<'de> for EmailRecipientVerifyError {
    fn deserialize<D: ::serde::de::Deserializer<'de>>(deserializer: D) -> Result<Self, D::Error> {
        // union deserializer
        use serde::de::{self, MapAccess, Visitor};
        struct EnumVisitor;
        impl<'de> Visitor<'de> for EnumVisitor {
            type Value = EmailRecipientVerifyError;
            fn expecting(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                f.write_str("a EmailRecipientVerifyError structure")
            }
            fn visit_map<V: MapAccess<'de>>(self, mut map: V) -> Result<Self::Value, V::Error> {
                let tag: &str = match map.next_key()? {
                    Some(".tag") => map.next_value()?,
                    _ => return Err(de::Error::missing_field(".tag")),
                };
                let value = match tag {
                    "bad_email" => EmailRecipientVerifyError::BadEmail,
                    "expired_code" => EmailRecipientVerifyError::ExpiredCode,
                    "bad_code" => EmailRecipientVerifyError::BadCode,
                    _ => EmailRecipientVerifyError::Other,
                };
                super::eat_json_fields(&mut map)?;
                Ok(value)
            }
        }
        const VARIANTS: &[&str] = &["bad_email", "expired_code", "bad_code", "other"];
        deserializer.deserialize_struct("EmailRecipientVerifyError", VARIANTS, EnumVisitor)
    }
}

impl ::serde::ser::Serialize for EmailRecipientVerifyError {
    fn serialize<S: ::serde::ser::Serializer>(&self, serializer: S) -> Result<S::Ok, S::Error> {
        // union serializer
        use serde::ser::SerializeStruct;
        match *self {
            EmailRecipientVerifyError::BadEmail => {
                // unit
                let mut s = serializer.serialize_struct("EmailRecipientVerifyError", 1)?;
                s.serialize_field(".tag", "bad_email")?;
                s.end()
            }
            EmailRecipientVerifyError::ExpiredCode => {
                // unit
                let mut s = serializer.serialize_struct("EmailRecipientVerifyError", 1)?;
                s.serialize_field(".tag", "expired_code")?;
                s.end()
            }
            EmailRecipientVerifyError::BadCode => {
                // unit
                let mut s = serializer.serialize_struct("EmailRecipientVerifyError", 1)?;
                s.serialize_field(".tag", "bad_code")?;
                s.end()
            }
            EmailRecipientVerifyError::Other => Err(::serde::ser::Error::custom(
                "cannot serialize 'Other' variant",
            )),
        }
    }
}

impl ::std::error::Error for EmailRecipientVerifyError {}

impl ::std::fmt::Display for EmailRecipientVerifyError {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        write!(f, "{:?}", *self)
    }
}
